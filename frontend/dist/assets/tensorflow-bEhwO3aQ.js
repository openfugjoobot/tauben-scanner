function y0(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Zc(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function r(){var s=!1;try{s=this instanceof r}catch{}return s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}const ep=1e-7,tp=1e-4;class ea{refCount(e){return ie("refCount")}incRef(e){return ie("incRef")}timerAvailable(){return!0}time(e){return ie("time")}read(e){return ie("read")}readSync(e){return ie("readSync")}readToGPU(e,t){return ie("readToGPU")}numDataIds(){return ie("numDataIds")}disposeData(e,t){return ie("disposeData")}write(e,t,r){return ie("write")}move(e,t,r,s,a){return ie("move")}createTensorFromGPUData(e,t,r){return ie("createTensorFromGPUData")}memory(){return ie("memory")}floatPrecision(){return ie("floatPrecision")}epsilon(){return this.floatPrecision()===32?ep:tp}dispose(){return ie("dispose")}}function ie(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function g(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function be(n,e,t=""){g(Pe(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function $t(n){g(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Y(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function np(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Pe(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Rt(n){return n%1===0}function Zt(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function En(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),g(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),g(n.every(r=>Rt(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function rp(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:En(e,n).sort();let o=0;for(let i=0;i<n.length;++i){if(a!=null){if(a[o]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(a[o]==null||a[o]>i)&&n[i]===1&&(t.push(n[i]),r.push(i)),a[o]<=i&&o++}n[i]!==1&&(t.push(n[i]),r.push(i))}return{newShape:t,keptDims:r}}function sp(n,e){return ta(n,e)}function ta(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function ap(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function op(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Un(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function ip(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Nr(n){return typeof n=="string"||n instanceof String}function up(n){return typeof n=="boolean"}function lp(n){return typeof n=="number"}function _n(n){return Array.isArray(n)?_n(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":lp(n)?"float32":Nr(n)?"string":up(n)?"bool":"float32"}function Wn(n){return!!(n&&n.constructor&&n.call&&n.apply)}function kr(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function na(n,e,t,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=t[n+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=na(n+u*i,o,t,r)}return s}function Kn(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,a)=>s*a)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return na(0,n,e,t)}function ra(n,e){const t=Sr(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Sr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function me(n){n.forEach(e=>{g(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function st(n){return n&&n.then&&typeof n.then=="function"}const vs="tfjsflags";class sa{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=cp,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(R().getBool("IS_TEST")||R().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];R().getBool("IS_TEST")||R().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(st(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);vs in e&&e[vs].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=hp(s,a)})}}function cp(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(pp(e,r[0],r[1]),r.join("="))),e}function pp(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function hp(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function R(){return Tr}let Tr=null;function mp(n){Tr=n}let Pn;function aa(){if(Pn==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Pn=n}return Pn}function dp(){const n=aa();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function vr(n,e){const t=dp();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const oa="Abs",ia="Acos",ua="Acosh",$r="Add",la="AddN",ca="All",pa="Any",ha="ArgMax",ma="ArgMin",da="Asin",fa="Asinh",ga="Atan",ya="Atanh",ba="Atan2",wa="AvgPool",Na="AvgPool3D",ka="BatchMatMul",Sa="BatchToSpaceND",Ta="Bincount",va="BitwiseAnd",$a="BroadcastArgs",Er="Cast",Ea="Ceil",_a="ClipByValue",xa="Complex",Ia="ComplexAbs",Aa="Concat",Da="Conv2D",Oa="Conv2DBackpropFilter",Ca="Conv2DBackpropInput",Fa="Conv3D",Ra="Conv3DBackpropInputV2",Pa="Cos",Ba="Cosh",La="Cumprod",za="Cumsum",Va="CropAndResize",ja="DenseBincount",qa="DepthToSpace",Ua="DepthwiseConv2dNative",Wa="DepthwiseConv2dNativeBackpropFilter",Ka="DepthwiseConv2dNativeBackpropInput",Ga="Diag",Ha="Dilation2D",Ma="RealDiv",Xa="Einsum",Ya="Elu",Ja="Erf",Qa="Equal",Za="Exp",eo="ExpandDims",to="Expm1",no="FFT",ro="Fill",so="FlipLeftRight",ao="Floor",oo="FloorDiv",io="FusedBatchNorm",uo="GatherV2",lo="GatherNd",co="Greater",po="GreaterEqual",_r="Identity",ho="IFFT",mo="Imag",fo="IsFinite",go="IsInf",yo="IsNan",bo="LeakyRelu",wo="Less",No="LessEqual",ko="LinSpace",So="Log",To="Log1p",vo="LogicalAnd",$o="LogicalNot",Eo="LogicalOr",_o="LRN",xo="Max",Io="Maximum",Ao="MaxPool",Do="MaxPool3D",Oo="MaxPoolWithArgmax",Co="Mean",Fo="Min",Ro="Minimum",Po="MirrorPad",Bo="Mod",Lo="Multinomial",zo="Multiply",Vo="Neg",jo="NotEqual",qo="NonMaxSuppressionV3",Uo="NonMaxSuppressionV4",Wo="NonMaxSuppressionV5",Ko="OnesLike",Go="OneHot",Ho="Pack",Mo="PadV2",Xo="Pow",Yo="Prelu",Jo="Prod",Qo="RaggedGather",Zo="RaggedRange",ei="RaggedTensorToTensor",ti="Range",ni="Real",ri="Reciprocal",si="Relu",ai="Reshape",oi="ResizeNearestNeighbor",ii="ResizeBilinear",ui="Relu6",li="Reverse",ci="Round",pi="Rsqrt",hi="ScatterNd",mi="TensorScatterUpdate",di="SearchSorted",fi="Select",gi="Selu",yi="Slice",bi="Sin",wi="Sinh",Ni="Sign",ki="Sigmoid",Si="Softplus",Ti="Sqrt",vi="Sum",$i="SpaceToBatchND",Ei="SplitV",_i="Softmax",xi="SparseFillEmptyRows",Ii="SparseReshape",Ai="SparseSegmentMean",Di="SparseSegmentSum",Oi="SparseToDense",Ci="SquaredDifference",Fi="StaticRegexReplace",Ri="StridedSlice",Pi="StringNGrams",Bi="StringSplit",Li="StringToHashBucketFast",zi="Sub",Vi="Tan",ji="Tanh",xr="Tile",qi="TopK",Ui="Transform",en="Transpose",Wi="Unique",Ki="Unpack",Gi="UnsortedSegmentSum",Hi="ZerosLike",Mi="Step",Gn="FromPixels",Xi="RotateWithOffset",Hn="_FusedMatMul",Mn="FusedConv2D",Xn="FusedDepthwiseConv2D";function It(...n){R().getBool("IS_TEST")||R().getBool("PROD")||console.warn(...n)}const Yi=vr("kernelRegistry",()=>new Map),fp=vr("gradRegistry",()=>new Map);function hn(n,e){const t=gp(n,e);return Yi.get(t)}function Yn(n){return fp.get(n)}function Jn(n){const e=Yi.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===n&&t.push(o)}return t}function gp(n,e){return`${e}_${n}`}function Ji(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function yp(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Qi(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Pt(n)),R().getBool("DEBUG")&&ap(n,e),yp(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function mn(){return R().platform.now()}function bp(n,e="utf-8"){return e=e||"utf-8",R().platform.encode(n,e)}function $s(n,e="utf-8"){return e=e||"utf-8",R().platform.decode(n,e)}function ye(n){return R().platform.isTypedArray!=null?R().platform.isTypedArray(n):Ji(n)}function Pt(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||st(n)||n==null||ye(n)&&t)e.push(n);else if(Array.isArray(n)||ye(n))for(let r=0;r<n.length;++r)Pt(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Pt(n[s],e,t)}return e}class wp{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new kp)}profileKernel(e,t,r){let s;const a=()=>{s=r()};let o;const i=mn();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();o=Promise.resolve({kernelMs:mn()-i})}if(R().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const p=s[l];p.data().then(h=>{Np(h,p.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:a,extraInfo:o}=e;r.forEach(i=>{Promise.all([i.data(),s,o]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],a,u[2])})})}}function Np(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class kp{logKernelProfile(e,t,r,s,a,o){const i=typeof s=="number"?Zt(`${s}ms`,9):s.error,u=Zt(e,25),l=t.rank,p=t.size,h=Zt(t.shape.toString(),14);let m="";for(const f in a){const b=a[f];if(b!=null){const k=b.shape||t.shape,N=k.length;m+=`${f}: ${N}D ${N>0?k:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${h}	%c${p}	%c${m}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Sp(n,e,t){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],p=l.inputs;for(const h in p){const m=p[h];let f=!1;for(let b=0;b<e.length;b++)if(r[m.id]){l.outputs.forEach(k=>r[k.id]=!0),f=!0,s[l.id]=!0;break}if(f)break}}const a={};a[t.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const l=n[u],p=l.inputs;for(let h=0;h<l.outputs.length;h++)if(a[l.outputs[h].id]){for(const m in p)a[p[m].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<n.length;u++){const l=n[u];if(s[l.id]&&o[l.id]){const p={};for(const m in l.inputs){const f=l.inputs[m];r[f.id]&&(p[m]=f)}const h=Object.assign({},l);h.inputs=p,h.outputs=l.outputs,i.push(h)}}return i}function Tp(n,e,t,r){for(let s=e.length-1;s>=0;s--){const a=e[s],o=[];if(a.outputs.forEach(u=>{const l=n[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=t(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const p=a.inputs[u];if(!Pe(l.shape,p.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${p.shape}'`);if(n[p.id]==null)n[p.id]=l;else{const h=n[p.id];n[p.id]=r(h,l),h.dispose()}}}}const Es=20,At=3,Bn=7;function vp(n,e,t,r){const s=kr(e),a=$p(n,e,t,s),o=e.length,i=tn(n,e,t,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function $p(n,e,t,r){const s=Y(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,u=t==="complex64"?Ct(n):n;if(i>1)for(let l=0;l<s/a;l++){const p=l*a;for(let h=0;h<a;h++)o[h]=Math.max(o[h],Ot(u[p+h],0,t).length)}return o}function Ot(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Bn))} + ${parseFloat(n[1].toFixed(Bn))}j`:Nr(n)?r=`'${n}'`:t==="bool"?r=Zi(n):r=parseFloat(n.toFixed(Bn)).toString(),Zt(r,e)}function Zi(n){return n===0?"false":"true"}function tn(n,e,t,r,s,a=!0){const o=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){const k=Ct(n);return[Ot(k[0],0,t)]}return t==="bool"?[Zi(n[0])]:[n[0].toString()]}if(u===1){if(i>Es){const N=At*o;let S=Array.from(n.slice(0,N)),x=Array.from(n.slice((i-At)*o,i*o));return t==="complex64"&&(S=Ct(S),x=Ct(x)),["["+S.map((I,v)=>Ot(I,s[v],t)).join(", ")+", ..., "+x.map((I,v)=>Ot(I,s[i-At+v],t)).join(", ")+"]"]}return["["+(t==="complex64"?Ct(n):Array.from(n)).map((N,S)=>Ot(N,s[S],t)).join(", ")+"]"]}const l=e.slice(1),p=r.slice(1),h=r[0]*o,m=[];if(i>Es){for(let k=0;k<At;k++){const N=k*h,S=N+h;m.push(...tn(n.slice(N,S),l,t,p,s,!1))}m.push("...");for(let k=i-At;k<i;k++){const N=k*h,S=N+h;m.push(...tn(n.slice(N,S),l,t,p,s,k===i-1))}}else for(let k=0;k<i;k++){const N=k*h,S=N+h;m.push(...tn(n.slice(N,S),l,t,p,s,k===i-1))}const f=u===2?",":"";m[0]="["+(i>0?m[0]+f:"");for(let k=1;k<m.length-1;k++)m[k]=" "+m[k]+f;let b=`,
`;for(let k=2;k<u;k++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(a?"":b),m}function Ct(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class dn{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Y(e),r!=null){const s=r.length;g(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||ta(t,this.size),this.strides=kr(e)}set(e,...t){t.length===0&&(t=[0]),g(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return we().makeTensor(this.values,this.shape,this.dtype)}}let we=null,ht=null;function Ep(n){we=n}function _p(n){ht=n}class Q{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Y(e),this.strides=kr(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ht.buffer(this.shape,this.dtype,e)}bufferSync(){return ht.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Kn(this.shape,e,this.dtype==="complex64")}arraySync(){return Kn(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=we().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>$s(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),we().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=we().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>$s(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await we().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),we().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ht.print(this,e)}clone(){return this.throwIfDisposed(),ht.clone(this)}toString(e=!1){const t=this.dataSync();return vp(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ht.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),we().makeVariable(this,e,t,r)}}Object.defineProperty(Q,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function eu(){return vr("Tensor",()=>Q)}eu();class Bt extends Q{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Pe(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);we().disposeTensor(this),this.dataId=e.dataId,we().incRef(this,null)}dispose(){we().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Bt,Symbol.hasInstance,{value:n=>n instanceof Q&&n.assign!=null&&n.assign instanceof Function});var Qn;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Qn||(Qn={}));var Zn;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Zn||(Zn={}));var er;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(er||(er={}));var tr;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(tr||(tr={}));var nr;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(nr||(nr={}));const xp={float32:tr,int32:Zn,bool:er,complex64:nr};function tu(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return xp[n][e]}function nu(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function ru(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function H(n,e){if(n.dtype===e.dtype)return[n,e];const t=tu(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Ip(n,e){g(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function su(n){const e=[];return au(n,e,new Set),e}function au(n,e,t){if(n==null)return;if(n instanceof Q){e.push(n);return}if(!Ap(n))return;const r=n;for(const s in r){const a=r[s];t.has(a)||(t.add(a),au(a,e,t))}}function Ap(n){return Array.isArray(n)||typeof n=="object"}function Ln(n){return n.kernelName!=null}class _s{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class bt{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new _s}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(It(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new wp(this.backendInstance),!0}setupRegisteredKernels(){Jn(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jn(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof ea)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,It(`Initialization of backend ${e} failed`),It(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return It(`Initialization of backend ${e} failed`),It(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,a=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,a,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return bt.nextTensorId++}nextVariableId(){return bt.nextVariableId++}clone(e){const t=w.runKernel(_r,{x:e}),r={x:e},s=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return w.runKernel(Er,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,a,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(hn(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-t-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=Ln(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ln(e)){const{kernelName:b,inputs:k,attrs:N}=e;this.backendName==null&&this.backend;const S=hn(b,this.backendName);g(S!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),i=()=>{const x=this.backend.numDataIds();u=S.kernelFunc({inputs:k,attrs:N,backend:this.backend});const I=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,x,I);const v=I.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(s){const E=this.getTensorsForGradient(b,k,v);r=this.saveTensorsForBackwardMode(E)}return v}}else{const{forwardFunc:b}=e,k=N=>{s&&(r=N.map(S=>this.keep(this.clone(S))))};i=()=>{const N=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,k));const S=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,N,S),S}}const{inputs:p,attrs:h}=e,m=Ln(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(f=this.profiler.profileKernel(l,p,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),s&&this.addTapeNode(l,p,t,m,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(b=>p[b]!=null?p[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=Yn(e);if(s!=null){const a=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?(g(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=a.map(l=>t[l]);const u=r.filter((l,p)=>o[p]);return i.concat(u)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&Nr(e[0])&&(a=e.map(u=>bp(u)));const o=s.write(a,t,r),i=new Q(t,r,o,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(o),l=ip(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,t,r,s){r=r||"float32";const a={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:a}=e,o=new Q(s,a,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new Bt(e,t,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Un(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Bt||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Un(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:a},u=Yn(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=l=>(l=l.map((p,h)=>{if(p==null){const m=r[h],f=Sr(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return p}),s(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=su(e),r=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,t,r,s=!1){if(g(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));g(a instanceof Q,()=>"The result y returned by f() must be a tensor.");const o=Sp(this.state.activeTape,t,a);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=r??Dp(a.shape),Tp(i,o,l=>this.tidy(l),Op);const u=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const p of l.saved)p.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return g(Wn(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{g(t.every(i=>i instanceof Q),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((i,u)=>{s[u]=i});const a=(i,u)=>(r=e(...t,u),g(r.value instanceof Q,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),g(Wn(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),p=Array.isArray(l)?l:[l];g(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),g(p.every(m=>m instanceof Q),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return p.forEach((m,f)=>{h[f]=()=>m}),h};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=mn(),r=await this.backend.time(e);return r.wallMs=mn()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new _s;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}bt.nextTensorId=0;bt.nextVariableId=0;function Dp(n){const e=ra(Y(n),"float32");return w.makeTensor(e,n,"float32")}function ou(){const n=aa();if(n._tfengine==null){const e=new sa(n);n._tfengine=new bt(e)}return mp(n._tfengine.ENV),Ep(()=>n._tfengine),n._tfengine}const w=ou();function Op(n,e){const t={a:n,b:e};return w.runKernel($r,t)}function Cp(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const oe=R();oe.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});oe.registerFlag("IS_BROWSER",()=>Cp());oe.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");oe.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));oe.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));oe.registerFlag("PROD",()=>!1);oe.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>oe.getBool("DEBUG"));oe.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);oe.registerFlag("IS_TEST",()=>!1);oe.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>oe.getBool("DEBUG"));oe.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);oe.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);oe.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ge(n,e){let t=n;if(ye(n))return e==="string"?[]:[n.length];if(nu(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(ru(n))return[n.buffer.size/(e==null?4:Un(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||ye(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&R().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&iu(n,r,[]),r}function iu(n,e,t){if(t=t||[],!Array.isArray(n)&&!ye(n)){g(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}g(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),g(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)iu(n[s],r,t.concat(s))}function xs(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function d(n,e,t,r="numeric"){if(n instanceof eu())return xs(r,n.dtype,e,t),n;let s=_n(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),xs(r,s,e,t),n==null||!ye(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const a=Ge(n,s);!ye(n)&&!Array.isArray(n)&&(n=[n]);const i=s!=="string"?Qi(n,s):Pt(n,[],!0);return w.makeTensor(i,a,s)}function fn(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,o)=>d(a,`${e}[${o}]`,t,r))}const Ir="__op";function y(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Ir;const s=(...a)=>{w.startScope(t);try{const o=r(...a);return st(o)&&console.error("Cannot return a Promise inside of tidy."),w.endScope(o),o}catch(o){throw w.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}function Fp(n,e){const t=d(n,"real","complex"),r=d(e,"imag","complex");be(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return w.runKernel(xa,s)}const Be=y({complex_:Fp});function He(n,e,t,r){if(r==null)r=_n(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ru(n)||nu(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return w.backend.createTensorFromGPUData(n,e||t,r)}if(!ye(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){me(e);const s=Y(e),a=Y(t);g(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<t.length;++o){const i=t[o],u=o===t.length-1?i!==Y(e.slice(o)):!0;g(t[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!ye(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Qi(n,r):Pt(n,[],!0),w.makeTensor(n,e,r)}function ke(n,e,t){const r=Ge(n,t);return He(n,e,r,t)}const at={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Te{static join(e){return new Te(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>ye(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+s.byteLength;this.shards.push({buffer:s,start:t,end:a}),t=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,a=new ArrayBuffer(s),o=new Uint8Array(a);let i=0;for(let u=r;u<this.shards.length;u++){const l=this.shards[u],h=e+i-l.start,m=i,b=Math.min(t,l.end)-l.start,k=new Uint8Array(l.buffer,h,b-h);if(o.set(k,m),i+=k.length,t<l.end)break}return a}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Rp(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Rp(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,a=e(n[s]);if(a===0)return s;a<0?r=s:t=s+1}return-1}function z(n,e){return w.tidy(n,e)}function se(n){su(n).forEach(t=>t.dispose())}function Ne(n){return w.keep(n)}function uu(){return w.backendName}function lu(){return w.backend}const qe=4;async function Pp(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const i=s[o],u=Array.isArray(n)?n[o].tensor:n[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const p=new Promise(async h=>{const m=await u.bytes(),f=m.reduce((N,S)=>N+S.length,0)+qe*m.length,b=new Uint8Array(f);let k=0;for(let N=0;N<m.length;N++){const S=m[N],x=new Uint8Array(new Uint32Array([S.length]).buffer);b.set(x,k),k+=qe,b.set(S,k),k+=S.length}h(b)});r.push(p)}else r.push(u.data());e!=null&&(l.group=e),t.push(l)}const a=await Promise.all(r);return{data:zp(a),specs:t}}function cu(n,e){const t=new Te(n),r={};let s=0;for(const a of e){const o=Bp(a,(i,u)=>t.slice(s+i,s+u));r[a.name]=pu(a,t.slice(s,s+o)),s+=o}return r}function Bp(n,e){const t=Y(n.shape);let r;if("quantization"in n){const s=n.quantization;r=at[s.dtype]}else if(n.dtype==="string"){let s=0;for(let a=0;a<t;a++)s+=qe+new Uint32Array(e(s,s+qe))[0];return s}else r=at[n.dtype];return t*r}async function Lp(n,e){const t=Y(n.shape);let r;if("quantization"in n){const s=n.quantization;r=at[s.dtype]}else if(n.dtype==="string"){let s=0;for(let a=0;a<t;a++)s+=qe+new Uint32Array(await e(s,s+qe))[0];return s}else r=at[n.dtype];return t*r}function pu(n,e){const t=n.name,r=n.dtype,s=n.shape,a=Y(s);let o,i=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=at[u.dtype],p=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){o=new Float32Array(p.length);for(let h=0;h<p.length;h++){const m=p[h];o[h]=m*u.scale+u.min}}else if(u.dtype==="float16")o=Gp()(p);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(r==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);o=new Int32Array(p.length);for(let h=0;h<p.length;h++){const m=p[h];o[h]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);i+=a*l}else if(r==="string"){const u=Y(n.shape);o=[];for(let l=0;l<u;l++){const p=new Uint32Array(e.slice(i,i+qe))[0];i+=qe;const h=new Uint8Array(e.slice(i,i+p));o.push(h),i+=p}}else{const u=at[r];if(r==="float32")o=new Float32Array(e);else if(r==="int32")o=new Int32Array(e);else if(r==="bool")o=new Uint8Array(e);else if(r==="complex64"){o=new Float32Array(e);const l=new Float32Array(o.length/2),p=new Float32Array(o.length/2);for(let b=0;b<l.length;b++)l[b]=o[b*2],p[b]=o[b*2+1];const h=ke(l,s,"float32"),m=ke(p,s,"float32"),f=Be(h,m);return h.dispose(),m.dispose(),f}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);i+=a*u}return ke(o,s,r)}async function Is(n,e,t){let r=new Uint8Array(e);for(;r.byteLength<t;){const{done:s,value:a}=await n.read();if(s&&a==null){const i=t-r.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const o=new Uint8Array(r.length+a.byteLength);o.set(r,0),o.set(new Uint8Array(a),r.length),r=o}return r.buffer}async function hu(n,e){const t={},r=n.getReader();let s=new ArrayBuffer(0);for(const a of e){const o=await Lp(a,async(l,p)=>(s=await Is(r,s,p),s.slice(l,p)));s=await Is(r,s,o);const i=s.slice(0,o);s=s.slice(o);const u=pu(a,i);if(t[a.name]=u,uu()==="webgpu"){const l=lu();"uploadToGPU"in l&&Y(u.shape)>=R().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return t}function zp(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const Ar=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function As(n){return Ar?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Vp(n){if(Ar)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function jp(n){if(Ar){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function qp(n){return Te.join(n)}function Ds(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function mu(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function du(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function Dr(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),du(n,t,r)}function Ut(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:As(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:As(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Te(n.weightData).byteLength}}function rr(n){const e=[];for(const t of n)e.push(...t.weights);return e}function Up(){const n=t=>{let r=t<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Wp(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Kp(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Gp(){const n=Up(),e=Wp(),t=Kp();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){const i=r[o],u=n[t[i>>10]+(i&1023)]+e[i>>10];a[o]=u}return new Float32Array(s)}}class K{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return K.instance==null&&(K.instance=new K),K.instance}static registerSaveRouter(e){K.getInstance().saveRouters.push(e)}static registerLoadRouter(e){K.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return K.getHandlers(e,"save")}static getLoadHandlers(e,t){return K.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?K.getInstance().loadRouters:K.getInstance().saveRouters).forEach(o=>{const i=o(e,r);i!==null&&s.push(i)}),s}}const Hp=n=>K.registerSaveRouter(n),Mp=n=>K.registerLoadRouter(n),Xp=n=>K.getSaveHandlers(n),Yp=(n,e)=>K.getLoadHandlers(n,e);const sr="tensorflowjs",ar=1,tt="models_store",Ve="model_info_store";function fu(){if(!R().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function or(n){const e=n.result;e.createObjectStore(tt,{keyPath:"modelPath"}),e.createObjectStore(Ve,{keyPath:"modelPath"})}class ot{constructor(e){if(this.indexedDB=fu(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const a=this.indexedDB.open(sr,ar);a.onupgradeneeded=()=>or(a),a.onsuccess=()=>{const o=a.result;if(t==null){const i=o.transaction(tt,"readonly"),l=i.objectStore(tt).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=p=>(o.close(),s(l.error)),i.oncomplete=()=>o.close()}else{t.weightData=Te.join(t.weightData);const i=Ut(t),u=o.transaction(Ve,"readwrite");let l=u.objectStore(Ve),p;try{p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(m){return s(m)}let h;p.onsuccess=()=>{h=o.transaction(tt,"readwrite");const m=h.objectStore(tt);let f;try{f=m.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(b){return s(b)}f.onsuccess=()=>r({modelArtifactsInfo:i}),f.onerror=b=>{l=u.objectStore(Ve);const k=l.delete(this.modelPath);k.onsuccess=()=>(o.close(),s(f.error)),k.onerror=N=>(o.close(),s(f.error))}},p.onerror=m=>(o.close(),s(p.error)),u.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}ot.URL_SCHEME="indexeddb://";const gu=n=>R().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ot.URL_SCHEME)?Jp(n.slice(ot.URL_SCHEME.length)):null;K.registerSaveRouter(gu);K.registerLoadRouter(gu);function Jp(n){return new ot(n)}function Qp(n){return n.startsWith(ot.URL_SCHEME)?n.slice(ot.URL_SCHEME.length):n}class Zp{constructor(){this.indexedDB=fu()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(sr,ar);r.onupgradeneeded=()=>or(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Ve,"readonly"),i=a.objectStore(Ve).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),t(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=Qp(e),new Promise((t,r)=>{const s=this.indexedDB.open(sr,ar);s.onupgradeneeded=()=>or(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(Ve,"readwrite"),i=o.objectStore(Ve),u=i.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const p=i.delete(e),h=()=>{l=a.transaction(tt,"readwrite");const f=l.objectStore(tt).delete(e);f.onsuccess=()=>t(u.result.modelArtifactsInfo),f.onerror=b=>r(u.error)};p.onsuccess=h,p.onerror=m=>(h(),a.close(),r(u.error))}},u.onerror=p=>(a.close(),r(u.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}const Ce="/",mt="tensorflowjs_models",yu="info",eh="model_topology",th="weight_specs",nh="weight_data",rh="model_metadata";function bu(n){return{info:[mt,n,yu].join(Ce),topology:[mt,n,eh].join(Ce),weightSpecs:[mt,n,th].join(Ce),weightData:[mt,n,nh].join(Ce),modelMetadata:[mt,n,rh].join(Ce)}}function wu(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function sh(n){const e=n.split(Ce);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Ce)}function ah(n){return n.startsWith(it.URL_SCHEME)?n.slice(it.URL_SCHEME.length):n}class it{constructor(e){if(!R().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=bu(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Ut(e),a=Te.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Vp(a));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw wu(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=jp(o),t}}it.URL_SCHEME="localstorage://";const Nu=n=>R().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(it.URL_SCHEME)?oh(n.slice(it.URL_SCHEME.length)):null;K.registerSaveRouter(Nu);K.registerLoadRouter(Nu);function oh(n){return new it(n)}class ih{constructor(){g(R().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),g(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=mt+Ce,r=Ce+yu;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(t)&&a.endsWith(r)){const o=sh(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=ah(e);const t=bu(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return wu(t),r}}const ft="://";class ne{constructor(){this.managers={}}static getInstance(){return ne.instance==null&&(ne.instance=new ne),ne.instance}static registerManager(e,t){g(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ft)&&(e=e.slice(0,e.indexOf(ft))),g(e.length>0,()=>"scheme must not be an empty string.");const r=ne.getInstance();g(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=ne.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ne.getInstance().managers)}}function nn(n){if(n.indexOf(ft)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ne.getSchemes().join(",")}`);return{scheme:n.split(ft)[0],path:n.split(ft)[1]}}async function ku(n,e,t=!1){g(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=K.getLoadHandlers(n);g(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),g(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],a=K.getSaveHandlers(e);g(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),g(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=a[0],i=nn(n).scheme,u=nn(n).path,l=i===nn(n).scheme,p=await s.load();t&&l&&await ne.getManager(i).removeModel(u);const h=await o.save(p);return t&&!l&&await ne.getManager(i).removeModel(u),h.modelArtifactsInfo}async function uh(){const n=ne.getSchemes(),e={};for(const t of n){const r=await ne.getManager(t).listModels();for(const s in r){const a=t+ft+s;e[a]=r[s]}}return e}async function lh(n){const e=nn(n);return ne.getManager(e.scheme).removeModel(e.path)}async function ch(n,e){return ku(n,e,!1)}async function ph(n,e){return ku(n,e,!0)}class hh{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!R().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Ji(e)}}if(R().get("IS_BROWSER")){R().setPlatform("browser",new hh);try{ne.registerManager(it.URL_SCHEME,new ih)}catch{}try{ne.registerManager(ot.URL_SCHEME,new Zp)}catch{}}const mh={importFetch:()=>require("node-fetch")};let zn;class dh{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return R().global.fetch!=null?R().global.fetch(e,t):(zn==null&&(zn=mh.importFetch()),zn(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}R().get("IS_NODE")&&!R().get("IS_BROWSER")&&R().setPlatform("node",new dh);function $e(n,e="float32",t){return e=e||"float32",me(n),new dn(n,e,t)}function fh(n,e){const t=d(n,"x","cast");if(!op(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return w.runKernel(Er,r,s)}const G=y({cast_:fh});function gh(n){const t={x:d(n,"x","clone","string_or_numeric")};return w.runKernel(_r,t)}const Fe=y({clone_:gh});function Or(n,e=!1){console.log(n.toString(e))}ou();const yh={buffer:$e,cast:G,clone:Fe,print:Or};_p(yh);function bh(n,e){let t=d(n,"a","add"),r=d(e,"b","add");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel($r,s)}const A=y({add_:bh});function wh(n,e){let t=d(n,"a","floorDiv"),r=d(e,"b","floorDiv");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(oo,s)}const Cr=y({floorDiv_:wh});function Nh(n,e){let t=d(n,"a","div"),r=d(e,"b","div");if([t,r]=H(t,r),t.dtype==="int32"&&r.dtype==="int32")return Cr(t,r);const s={a:t,b:r},a={};return w.runKernel(Ma,s,a)}const U=y({div_:Nh});function kh(n,e){let t=d(n,"a","mul"),r=d(e,"b","mul");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(zo,s)}const $=y({mul_:kh});function Sh(n){const e=d(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return w.runKernel(Ia,t)}else{const t={x:e};return w.runKernel(oa,t)}}const ce=y({abs_:Sh});function Th(n){const t={x:d(n,"x","acos")};return w.runKernel(ia,t)}const Su=y({acos_:Th});function vh(n){const t={x:d(n,"x","acosh")};return w.runKernel(ua,t)}const Tu=y({acosh_:vh});function $h(n){g(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),g(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,a)=>d(s,`tensors${a}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Pe(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return w.runKernel(la,r)}const vu=y({addN_:$h});function Eh(n,e=null,t=!1){const s={x:d(n,"x","all","bool")},a={axis:e,keepDims:t};return w.runKernel(ca,s,a)}const $u=y({all_:Eh});function _h(n,e=null,t=!1){const s={x:d(n,"x","any","bool")},a={axis:e,keepDims:t};return w.runKernel(pa,s,a)}const Eu=y({any_:_h});function xh(n,e=0){const r={x:d(n,"x","argMax")},s={axis:e};return w.runKernel(ha,r,s)}const _u=y({argMax_:xh});function Ih(n,e=0){const r={x:d(n,"x","argMin")},s={axis:e};return w.runKernel(ma,r,s)}const xu=y({argMin_:Ih});function Ah(n){const t={x:d(n,"x","asin")};return w.runKernel(da,t)}const Iu=y({asin_:Ah});function Dh(n){const t={x:d(n,"x","asinh")};return w.runKernel(fa,t)}const Au=y({asinh_:Dh});function Oh(n){const t={x:d(n,"x","atan")};return w.runKernel(ga,t)}const Du=y({atan_:Oh});function Ch(n,e){let t=d(n,"a","atan2"),r=d(e,"b","atan2");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(ba,s)}const Ou=y({atan2_:Ch});function Fh(n){const t={x:d(n,"x","atanh")};return w.runKernel(ya,t)}const Cu=y({atanh_:Fh});function Rh(n,e,t,r,s,a,o="channelsLast"){const[i,u]=Lt(e);let l;if(o==="channelsLast")l=[i,u,n[3],n[3]];else if(o==="channelsFirst")l=[i,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Fr(n,l,t,r,s,a,!1,o)}function Fr(n,e,t,r,s,a,o=!1,i="channelsLast"){let[u,l,p,h]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,p,h]=n;else if(i==="channelsFirst")[u,h,l,p]=n;else throw new Error(`Unknown dataFormat ${i}`);const[m,f,,b]=e,[k,N]=Lt(t),[S,x]=Lt(r),I=ir(m,S),v=ir(f,x),{padInfo:E,outHeight:_,outWidth:D}=Lh(s,l,p,k,N,I,v,a,i),O=o?b*h:b;let C;return i==="channelsFirst"?C=[u,O,_,D]:i==="channelsLast"&&(C=[u,_,D,O]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:p,inChannels:h,outHeight:_,outWidth:D,outChannels:O,padInfo:E,strideHeight:k,strideWidth:N,filterHeight:m,filterWidth:f,effectiveFilterHeight:I,effectiveFilterWidth:v,dilationHeight:S,dilationWidth:x,inShape:n,outShape:C,filterShape:e}}function Ph(n,e,t,r,s){r==null&&(r=Bh(n,e,t));const a=n[0],o=n[1],i=gn((a-e+2*r)/t+1,s),u=gn((o-e+2*r)/t+1,s);return[i,u]}function Bh(n,e,t,r=1){const s=ir(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Lt(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function ir(n,e){return e<=1?n:n+(n-1)*(e-1)}function Lh(n,e,t,r,s,a,o,i,u){let l,p,h;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const f=Ph([e,t],a,r,n,i);p=f[0],h=f[1]}else if(n==="same"){p=Math.ceil(e/r),h=Math.ceil(t/s);const m=Math.max(0,(p-1)*r+a-e),f=Math.max(0,(h-1)*s+o-t),b=Math.floor(m/2),k=m-b,N=Math.floor(f/2),S=f-N;l={top:b,bottom:k,left:N,right:S,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-a+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const m=u==="channelsLast"?n[1][0]:n[2][0],f=u==="channelsLast"?n[1][1]:n[2][1],b=u==="channelsLast"?n[2][0]:n[3][0],k=u==="channelsLast"?n[2][1]:n[3][1];l={top:m,bottom:f,left:b,right:k,type:m===0&&f===0&&b===0&&k===0?"VALID":"EXPLICIT"},p=gn((e-a+m+f)/r+1,i),h=gn((t-o+b+k)/s+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:p,outWidth:h}}function gn(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function yn(n){const[e,t,r]=Lt(n);return e===1&&t===1&&r===1}function Me(n,e){return yn(n)||yn(e)}function wt(n){return Lt(n).every(e=>e>0)}function ve(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")g(Rt(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{g(Rt(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function zh(n,e){const r={x:d(n,"x","reshape","string_or_numeric")},s={shape:e};return w.runKernel(ai,r,s)}const T=y({reshape_:zh});function Vh(n,e,t,r,s){const a=d(n,"x","avgPool","float32"),o=1;g(Me(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=T(a,[1,a.shape[0],a.shape[1],a.shape[2]])),g(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ve("avgPool",r,s);const l={x:i},p={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=w.runKernel(wa,l,p);return h=G(h,a.dtype),u?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Rr=y({avgPool_:Vh});function jh(n,e,t,r,s,a="NDHWC"){const o=d(n,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),g(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),g(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ve("avgPool3d",r,s);const l={x:i},p={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:a};let h=w.runKernel(Na,l,p);return h=G(h,i.dtype),u?T(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Fu=y({avgPool3d_:jh});function qh(n,e=0){g(n.length>=1,()=>"Pass at least one tensor to concat");const t=fn(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return Fe(t[0]);const r=t,s={axis:e};return w.runKernel(Aa,r,s)}const te=y({concat_:qh});function Uh(n,e,t=!1,r=!1){let s=d(n,"a","matMul"),a=d(e,"b","matMul");[s,a]=H(s,a);const o={a:s,b:a},i={transposeA:t,transposeB:r};return w.runKernel(ka,o,i)}const V=y({matMul_:Uh});function Wh(n){const t={x:d(n,"x","sigmoid","float32")};return w.runKernel(ki,t)}const nt=y({sigmoid_:Wh});function Kh(n,e,t){const r=d(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:t};return w.runKernel(yi,s,a)}const j=y({slice_:Kh});function Gh(n){const t={x:d(n,"x","tanh","float32")};return w.runKernel(ji,t)}const bn=y({tanh_:Gh});function Hh(n,e,t,r,s,a){const o=d(n,"forgetBias","basicLSTMCell"),i=d(e,"lstmKernel","basicLSTMCell"),u=d(t,"lstmBias","basicLSTMCell"),l=d(r,"data","basicLSTMCell"),p=d(s,"c","basicLSTMCell"),h=d(a,"h","basicLSTMCell"),m=te([l,h],1),f=V(m,i),b=A(f,u),k=b.shape[0],N=b.shape[1]/4,S=[k,N],x=j(b,[0,0],S),I=j(b,[0,N],S),v=j(b,[0,N*2],S),E=j(b,[0,N*3],S),_=A($(nt(x),bn(I)),$(p,nt(A(o,v)))),D=$(bn(_),nt(E));return[_,D]}const Ru=y({basicLSTMCell_:Hh});function Mh(n,e,t){const r=d(n,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);g(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),g(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),g(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},o={blockShape:e,crops:t};return w.runKernel(Sa,a,o)}const Pr=y({batchToSpaceND_:Mh});function Xh(n){let e;return n.rank===0||n.rank===1?e=T(n,[1,1,1,n.size]):n.rank===2?e=T(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=T(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function Yh(n,e,t,r,s,a){a==null&&(a=.001);const o=d(n,"x","batchNorm"),i=d(e,"mean","batchNorm"),u=d(t,"variance","batchNorm");let l;s!=null&&(l=d(s,"scale","batchNorm"));let p;r!=null&&(p=d(r,"offset","batchNorm")),g(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),g(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),g(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:Xh(o),scale:l,offset:p,mean:i,variance:u},f={varianceEpsilon:a},b=w.runKernel(io,m,f);return T(b,o.shape)}const Wt=y({batchNorm_:Yh});function Jh(n,e,t,r,s,a){const o=d(n,"x","batchNorm"),i=d(e,"mean","batchNorm"),u=d(t,"variance","batchNorm");let l;s!=null&&(l=d(s,"scale","batchNorm"));let p;return r!=null&&(p=d(r,"offset","batchNorm")),g(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),g(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),g(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&g(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&g(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Wt(o,i,u,p,l,a)}const Pu=y({batchNorm2d_:Jh});function Qh(n,e,t,r,s,a){const o=d(n,"x","batchNorm"),i=d(e,"mean","batchNorm"),u=d(t,"variance","batchNorm");let l;s!=null&&(l=d(s,"scale","batchNorm"));let p;return r!=null&&(p=d(r,"offset","batchNorm")),g(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),g(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),g(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&g(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&g(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Wt(o,i,u,p,l,a)}const Bu=y({batchNorm3d_:Qh});function Zh(n,e,t,r,s,a){const o=d(n,"x","batchNorm"),i=d(e,"mean","batchNorm"),u=d(t,"variance","batchNorm");let l;s!=null&&(l=d(s,"scale","batchNorm"));let p;return r!=null&&(p=d(r,"offset","batchNorm")),g(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),g(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),g(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&g(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&g(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Wt(o,i,u,p,l,a)}const Lu=y({batchNorm4d_:Zh});function em(n,e,t){const r=d(n,"x","bincount"),s=d(e,"weights","bincount");g(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),g(t>=0,()=>`size must be non-negative, but got ${t}.`),g(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},o={size:t};return w.runKernel(Ta,a,o)}const Br=y({bincount_:em});function tm(n,e){const t=d(n,"x","bitwiseAnd"),r=d(e,"y","bitwiseAnd");if(!Pe(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return w.runKernel(va,s)}const zu=y({bitwiseAnd_:tm});function nm(n,e){const t=d(n,"s0","broadcastArgs","int32"),r=d(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return w.runKernel($a,s)}const Vu=y({broadcastArgs_:nm});function rm(n,e){let t=d(n,"broadcastTo","x");const r=t.shape;if(me(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=T(t,l)}const s=t.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return Fe(t);const i={x:t},u={reps:a};return w.runKernel(xr,i,u)}const Ft=y({broadcastTo_:rm});function sm(n){const t={x:d(n,"x","ceil","float32")};return w.runKernel(Ea,t)}const ju=y({ceil_:sm});function Et(n,e,t){me(n),t=t||_n(e);const r={shape:n,value:e,dtype:t};return w.runKernel(ro,{},r)}function am(n,e,t){const r=d(n,"x","clipByValue");if(g(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Et(r.shape,e,r.dtype);const s={x:r},a={clipValueMin:e,clipValueMax:t};return w.runKernel(_a,s,a)}const qu=y({clipByValue_:am});function om(n){return te(n,0)}const Uu=y({concat1d_:om});function im(n,e){return te(n,e)}const Wu=y({concat2d_:im});function um(n,e){return te(n,e)}const Ku=y({concat3d_:um});function lm(n,e){return te(n,e)}const Gu=y({concat4d_:lm});function cm(n,e,t,r,s="NHWC",a=[1,1],o){const i=d(n,"x","conv2d","float32"),u=d(e,"filter","conv2d","float32");let l=i,p=!1;i.rank===3&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),g(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ve("conv2d",r,o);const h=s==="NHWC"?l.shape[3]:l.shape[1];g(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),g(Me(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),g(wt(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),g(wt(t),()=>"Error in conv2D: Strides should be larger than 0.");const m={x:l,filter:u},f={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=w.runKernel(Da,m,f);return p?T(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Kt=y({conv2d_:cm});function pm(n,e,t,r,s="NWC",a=1,o){const i=d(n,"x","conv1d"),u=d(e,"filter","conv1d");let l=i,p=!1;i.rank===2&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1]])),g(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),g(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ve("conv1d",r,o),g(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),g(Me(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),g(wt(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),g(wt(t),()=>"Error in conv1D: Stride should be larger than 0."),g(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=T(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=T(l,[l.shape[0],1,l.shape[1],l.shape[2]]),N=Kt(m,h,[1,t],r,"NHWC",[1,a],o);return p?T(N,[N.shape[2],N.shape[3]]):T(N,[N.shape[0],N.shape[2],N.shape[3]])}const Hu=y({conv1d_:pm});function hm(n,e,t,r,s,a="NHWC",o){g(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,u=e,l=!1;e.rank===3&&(l=!0,u=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),g(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),g(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),g(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const p=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?u.shape[3]:u.shape[1];g(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),g(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),ve("conv2dDerInput",s,o);const m={dy:u,filter:t},f={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},b=w.runKernel(Ca,m,f);return l?T(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const Mu=y({conv2DBackpropInput_:hm});function mm(n,e,t,r,s,a){const o=d(n,"x","conv2dTranspose"),i=d(e,"filter","conv2dTranspose");return Mu(t,o,i,r,s,"NHWC",a)}const Xu=y({conv2dTranspose_:mm});function dm(n,e,t,r,s="NDHWC",a=[1,1,1]){const o=d(n,"x","conv3d"),i=d(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),g(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),g(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),g(Me(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),g(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),g(wt(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),g(wt(t),()=>"Error in conv3D: Strides should be larger than 0.");const p={x:u,filter:i},h={strides:t,pad:r,dataFormat:s,dilations:a},m=w.runKernel(Fa,p,h);return l?T(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const Yu=y({conv3d_:dm});function fm(n,e,t,r,s){g(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,o=e,i=!1;e.rank===4&&(i=!0,o=T(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const u=a[4],l=o.shape[4];g(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),g(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),g(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),g(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),g(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const p={dy:o,filter:t},h={pad:s,strides:r,inputShape:a},m=w.runKernel(Ra,p,h);return i?T(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const gm=y({conv3DBackpropInput_:fm});function ym(n,e,t,r,s){const a=d(n,"x","conv3dTranspose"),o=d(e,"filter","conv3dTranspose");return gm(t,a,o,r,s)}const Ju=y({conv3dTranspose_:ym});function bm(n){const t={x:d(n,"x","cos","float32")};return w.runKernel(Pa,t)}const Qu=y({cos_:bm});function wm(n){const t={x:d(n,"x","cosh","float32")};return w.runKernel(Ba,t)}const Zu=y({cosh_:wm});function Nm(n,e=0,t=!1,r=!1){const a={x:d(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return w.runKernel(La,a,o)}const el=y({cumprod_:Nm});function km(n,e=0,t=!1,r=!1){const a={x:d(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return w.runKernel(za,a,o)}const tl=y({cumsum_:km});function Sm(n,e,t,r=!1){const s=d(n,"x","denseBincount"),a=d(e,"weights","denseBincount");g(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),g(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),g(t>=0,()=>`size must be non-negative, but got ${t}.`),g(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const o={x:s,weights:a},i={size:t,binaryOutput:r};return w.runKernel(ja,o,i)}const nl=y({denseBincount_:Sm});function Tm(n,e,t="NHWC"){const r=d(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],a=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];g(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),g(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),g(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),g(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:t};return w.runKernel(qa,i,u)}const rl=y({depthToSpace_:Tm});function vm(n,e,t,r,s="NHWC",a=[1,1],o){const i=d(n,"x","depthwiseConv2d","float32"),u=d(e,"filter","depthwiseConv2d","float32");let l=i,p=!1;i.rank===3&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),g(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=s==="NHWC"?l.shape[3]:l.shape[1];g(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),ve("depthwiseConv2d",r,o);const m={x:l,filter:u},f={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},b=w.runKernel(Ua,m,f);return p?T(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const xn=y({depthwiseConv2d_:vm});function $m(n){const t={x:d(n,"x","diag")};return w.runKernel(Ga,t)}const sl=y({diag_:$m});function Em(n,e,t,r,s=[1,1],a="NHWC"){const o=d(n,"x","dilation2d"),i=d(e,"filter","dilation2d");g(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),g(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),g(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=T(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),g(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const p={x:u,filter:i},h={strides:t,pad:r,dilations:s},m=w.runKernel(Ha,p,h);return l?T(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const al=y({dilation2d_:Em});function _m(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],a=e.length-r-1,o=e[a];(s==null||s===1&&o>1)&&t.unshift(a)}return t}function J(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let a=n[n.length-s-1];a==null&&(a=1);let o=e[e.length-s-1];if(o==null&&(o=1),a===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=a;else if(a!==o){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else r[t-s-1]=a}return r}function xm(n,e){let t=d(n,"a","equal","string_or_numeric"),r=d(e,"b","equal","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(Qa,s)}const Lr=y({equal_:xm});function Im(n,e,t){const r=d(e,"a","where"),s=d(t,"b","where"),a=d(n,"condition","where","bool"),o=J(J(a.shape,r.shape),s.shape),i=Ft(a,o),u=Ft(r,o),l=Ft(s,o),p={condition:i,t:u,e:l};return w.runKernel(fi,p)}const Re=y({where_:Im});function Am(n){const t={x:d(n,"x","zerosLike")};return w.runKernel(Hi,t)}const pe=y({zerosLike_:Am});function Dm(n,e){let t=d(n,"a","div"),r=d(e,"b","div");[t,r]=H(t,r);const s=U(t,r),a=pe(s),o=Lr(r,a);return Re(o,a,s)}const ol=y({divNoNan_:Dm});function Om(n,e){const t=d(n,"t1","dot"),r=d(e,"t2","dot");g((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],a=r.rank===1?r.size:r.shape[0];if(g(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),t.rank===1&&r.rank===1){const o=T(t,[1,-1]),i=T(r,[-1,1]),u=V(o,i);return T(u,[])}else if(t.rank===1&&r.rank===2){const o=T(t,[1,-1]),i=T(r,[r.shape[0],r.shape[1]]),u=V(o,i);return T(u,[u.size])}else if(t.rank===2&&r.rank===1){const o=T(r,[-1,1]),i=V(t,o);return T(i,[i.size])}else{const o=T(r,[r.shape[0],r.shape[1]]);return V(t,o)}}const il=y({dot_:Om});function Cm(n,...e){const t=e.map((s,a)=>d(s,`tensors${a}`,"einsum")),r={equation:n};return w.runKernel(Xa,t,r)}const Qe=y({einsum_:Cm});function Fm(n){const t={x:d(n,"x","elu","float32")};return w.runKernel(Ya,t)}const zr=y({elu_:Fm});function Rm(n,e){const t=d(n,"x","ensureShape","string_or_numeric");if(!np(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const ul=y({ensureShape_:Rm});function Pm(n){let e=d(n,"x","erf");g(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=G(e,"float32"));const t={x:e};return w.runKernel(Ja,t)}const ll=y({erf_:Pm});function Bm(n,e,t){const r=n.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?s.push(n[a++]):s.push(e[o++]);return s}function In(n,e){const t=e.map(r=>1);return Bm(n,t,e)}function Lm(n,e=null,t=!1){const s={x:d(n,"x","max")},a={reductionIndices:e,keepDims:t};return w.runKernel(xo,s,a)}const rt=y({max_:Lm});function zm(n,e=null,t=!1){const s={x:d(n,"x","min")},a={axis:e,keepDims:t};return w.runKernel(Fo,s,a)}const wn=y({min_:zm});function Vm(n,e){let t=d(n,"base","pow"),r=d(e,"exp","pow");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(Xo,s)}const Nt=y({pow_:Vm});function B(n,e){if((ye(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&ye(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return He(n,[],[],e)}function jm(n){const t={x:d(n,"x","sqrt","float32")};return w.runKernel(Ti,t)}const Ee=y({sqrt_:jm});function qm(n){const e=d(n,"x","square"),t={};return w.runKernel("Square",{x:e},t)}const ge=y({square_:qm});function Um(n,e=null,t=!1){let r=d(n,"x","sum");r.dtype==="bool"&&(r=G(r,"int32"));const s={x:r},a={axis:e,keepDims:t};return w.runKernel(vi,s,a)}const q=y({sum_:Um});function Wm(n,e="euclidean",t=null,r=!1){n=d(n,"x","norm");const s=cl(n,e,t);let a=s.shape;if(r){const o=En(t,n.shape);a=In(s.shape,o)}return T(s,a)}function cl(n,e,t=null){if(n.rank===0)return ce(n);if(n.rank!==1&&t===null)return cl(T(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return q(ce(n),t);if(e===1/0)return rt(ce(n),t);if(e===-1/0)return wn(ce(n),t);if(e==="euclidean"||e===2)return Ee(q(Nt(ce(n),B(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return rt(q(ce(n),t[0]),t[1]-1);if(e===1/0)return rt(q(ce(n),t[1]),t[0]);if(e===-1/0)return wn(q(ce(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ee(q(ge(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Gt=y({norm_:Wm});function Km(n,e=null,t=!1){return Gt(n,"euclidean",e,t)}const pl=y({euclideanNorm_:Km});function Gm(n){const t={x:d(n,"x","exp")};return w.runKernel(Za,t)}const Ue=y({exp_:Gm});function Hm(n,e=0){const t=d(n,"x","expandDims","string_or_numeric");g(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return w.runKernel(eo,r,s)}const Ae=y({expandDims_:Hm});function Mm(n){const t={x:d(n,"x","expm1")};return w.runKernel(to,t)}const hl=y({expm1_:Mm});function Xm(n,e){const t=d(n,"x","tile","string_or_numeric");g(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return w.runKernel(xr,r,s)}const gt=y({tile_:Xm});function Ym(n,e,t,r="float32"){e==null&&(e=n);const s=$e([n,e],r),a=n<=e?n:e;for(let i=0;i<a;++i)s.set(1,i,i);const o=T(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return gt(Ae(o,0),[t[0],1,1]);if(t.length===2)return gt(Ae(Ae(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return gt(Ae(Ae(Ae(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Vr=y({eye_:Ym});function Jm(n){const t={x:d(n,"x","floor","float32")};return w.runKernel(ao,t)}const jr=y({floor_:Jm});function Qm(n,e,t=0,r=0){const s=d(n,"x","gather"),a=d(e,"indices","gather","int32"),o={x:s,indices:a},i={axis:t,batchDims:r};return w.runKernel(uo,o,i)}const qr=y({gather_:Qm});function Zm(n,e){let t=d(n,"a","greater","string_or_numeric"),r=d(e,"b","greater","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(co,s)}const Ht=y({greater_:Zm});function ed(n,e){let t=d(n,"a","greaterEqual","string_or_numeric"),r=d(e,"b","greaterEqual","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(po,s)}const Ur=y({greaterEqual_:ed});function td(n){const t={input:d(n,"input","imag")};return w.runKernel(mo,t)}const Mt=y({imag_:td});function nd(n){const t={x:d(n,"x","isFinite")};return w.runKernel(fo,t)}const ml=y({isFinite_:nd});function rd(n){const t={x:d(n,"x","isInf")};return w.runKernel(go,t)}const dl=y({isInf_:rd});function sd(n){const t={x:d(n,"x","isNaN")};return w.runKernel(yo,t)}const fl=y({isNaN_:sd});function ad(n,e=.2){const r={x:d(n,"x","leakyRelu")},s={alpha:e};return w.runKernel(bo,r,s)}const Wr=y({leakyRelu_:ad});function od(n,e){let t=d(n,"a","less","string_or_numeric"),r=d(e,"b","less","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(wo,s)}const Nn=y({less_:od});function id(n,e){let t=d(n,"a","lessEqual","string_or_numeric"),r=d(e,"b","lessEqual","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(No,s)}const An=y({lessEqual_:id});function gl(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return w.runKernel(ko,{},r)}function ud(n,e=5,t=1,r=1,s=.5){const a=d(n,"x","localResponseNormalization");g(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),g(Rt(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=T(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},l={depthRadius:e,bias:t,alpha:r,beta:s},p=w.runKernel(_o,u,l);return i?T(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const yl=y({localResponseNormalization_:ud});function ld(n){const t={x:d(n,"x","log","float32")};return w.runKernel(So,t)}const kt=y({log_:ld});function cd(n){const t={x:d(n,"x","log1p")};return w.runKernel(To,t)}const Kr=y({log1p_:cd});function bl(n,e){g(Wn(n),()=>"The f passed in variableGrads(f) must be a function"),g(e==null||Array.isArray(e)&&e.every(l=>l instanceof Bt),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in w.registeredVariables)e.push(w.registeredVariables[l])}const r=t?e.filter(l=>!l.trainable):null,s=e.length;e=e.filter(l=>l.trainable),g(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:o,grads:i}=w.gradients(n,e,null,a);g(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),g(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return e.forEach((l,p)=>{i[p]!=null&&(u[l.name]=i[p])}),r?.forEach(l=>u[l.name]=null),{value:o,grads:u}}function _e(n){return w.customGrad(n)}function pd(n){const t={x:d(n,"x","neg")};return w.runKernel(Vo,t)}const Se=y({neg_:pd});function hd(n){const t={x:d(n,"x","softplus")};return w.runKernel(Si,t)}const Gr=y({softplus_:hd});function md(n){const e=d(n,"x","logSigmoid");return _e(r=>({value:Se(Gr(Se(r))),gradFunc:o=>$(o,nt(Se(r)))}))(e)}const wl=y({logSigmoid_:md});function dd(n,e){let t=d(n,"a","sub"),r=d(e,"b","sub");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(zi,s)}const F=y({sub_:dd});function fd(n,e=-1){const t=d(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return _e((s,a)=>{const i=rt(s,e,!0),u=F(s,i),l=F(G(u,"float32"),kt(q(Ue(u),e,!0)));return a([l]),{value:l,gradFunc:(h,m)=>{const[f]=m,b=!0,k=Ue(f);return F(h,$(q(h,e,b),k))}}})(t)}const Nl=y({logSoftmax_:fd});function gd(n,e=null,t=!1){const r=d(n,"x","logSumExp"),s=En(e,r.shape),a=rt(r,s,!0),o=F(r,a),i=Ue(o),u=q(i,s),l=kt(u),p=A(T(a,l.shape),l);if(t){const h=In(p.shape,s);return T(p,h)}return p}const Hr=y({logSumExp_:gd});function yd(n,e){const t=d(n,"a","logicalAnd","bool"),r=d(e,"b","logicalAnd","bool");J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(vo,s)}const zt=y({logicalAnd_:yd});function bd(n){const t={x:d(n,"x","logicalNot","bool")};return w.runKernel($o,t)}const Mr=y({logicalNot_:bd});function wd(n,e){const t=d(n,"a","logicalOr","bool"),r=d(e,"b","logicalOr","bool");J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(Eo,s)}const Xr=y({logicalOr_:wd});function Nd(n,e){const t=d(n,"a","logicalXor","bool"),r=d(e,"b","logicalXor","bool");return J(t.shape,r.shape),zt(Xr(n,e),Mr(zt(n,e)))}const kl=y({logicalXor_:Nd});const Jt=2147483648;function kd(n,e,t="left"){const r=d(n,"sortedSequence","searchSorted"),s=d(e,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=T(r,[-1,a]),u=T(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Y(u.shape)>=Jt)throw new Error(`values tensor size must less than ${Jt}`);if(i.shape[1]>=Jt)throw new Error(`trailing dim_size must less than ${Jt} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},p={side:t};return w.runKernel(di,l,p)}const Dn=y({searchSorted_:kd});function Sl(n,e){return Dn(n,e,"left")}function Sd(n,e,t,r,s){const a=d(n,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=T(a,[1,a.shape[0],a.shape[1],a.shape[2]])),g(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),g(Me(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ve("maxPool",r,s);const l={x:i},p={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=w.runKernel(Ao,l,p);return u?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Yr=y({maxPool_:Sd});function Td(n,e=[1,1,1],t,r,s,a="NDHWC"){const o=d(n,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),g(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),g(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ve("maxPool3d",r,s);const l={x:i},p={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:a},h=w.runKernel(Do,l,p);return u?T(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Tl=y({maxPool3d_:Td});function vd(n,e,t,r,s=!1){const o={x:d(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=w.runKernel(Oo,o,i);return{result:u[0],indexes:u[1]}}const vl=y({maxPoolWithArgmax_:vd});function $d(n,e){let t=d(n,"a","maximum"),r=d(e,"b","maximum");[t,r]=H(t,r),t.dtype==="bool"&&(t=G(t,"int32"),r=G(r,"int32")),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(Io,s)}const Jr=y({maximum_:$d});function Ed(n,e=null,t=!1){const s={x:d(n,"x","mean")},a={axis:e,keepDims:t};return w.runKernel(Co,s,a)}const Vt=y({mean_:Ed});function We(n,e="float32"){if(me(n),e==="complex64"){const r=We(n,"float32"),s=We(n,"float32");return Be(r,s)}const t=Sr(Y(n),e);return w.makeTensor(t,n,e)}function je(n,e="float32"){if(me(n),e==="complex64"){const r=je(n,"float32"),s=We(n,"float32");return Be(r,s)}const t=ra(Y(n),e);return w.makeTensor(t,n,e)}function $l(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=d(n,"x","meshgrid",n instanceof Q?n.dtype:"float32");if(e===void 0)return[r];let s=d(e,"y","meshgrid",e instanceof Q?e.dtype:"float32");const a=Y(r.shape),o=Y(s.shape);return t==="xy"?(r=T(r,[1,-1]),s=T(s,[-1,1]),[V(je([o,1],r.dtype),r),V(s,je([1,a],s.dtype))]):(r=T(r,[-1,1]),s=T(s,[1,-1]),[V(r,je([1,o],r.dtype)),V(je([a,1],s.dtype),s)])}function _d(n,e){let t=d(n,"a","minimum"),r=d(e,"b","minimum");[t,r]=H(t,r),t.dtype==="bool"&&(t=G(t,"int32"),r=G(r,"int32")),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(Ro,s)}const jt=y({minimum_:_d});function xd(n,e,t){g(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=d(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");g(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let i=0;i<r.rank;i++)g(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),g(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:t},o={x:r};return w.runKernel(Po,o,a)}const El=y({mirrorPad_:xd});function Id(n,e){let t=d(n,"a","mod"),r=d(e,"b","mod");[t,r]=H(t,r);const s={a:t,b:r};return w.runKernel(Bo,s)}const _l=y({mod_:Id});function Ad(n,e=null,t=!1){n=d(n,"x","moments");const r=En(e,n.shape),s=Vt(n,r,t);let a=s.shape;t||(a=In(s.shape,r));const o=ge(F(G(n,"float32"),T(s,a))),i=Vt(o,r,t);return{mean:s,variance:i}}const xl=y({moments_:Ad});function Dd(n,e,t,r){const s=d(e,"data","multiRNNCell"),a=fn(t,"c","multiRNNCell"),o=fn(r,"h","multiRNNCell");let i=s;const u=[];for(let h=0;h<n.length;h++){const m=n[h](i,a[h],o[h]);u.push(m[0]),u.push(m[1]),i=m[1]}const l=[],p=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),p.push(u[h+1]);return[l,p]}const Il=y({multiRNNCell_:Dd});function Od(n,e,t,r=!1){const s=d(n,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const u={logits:o===1?T(s,[1,-1]):s},l={numSamples:e,seed:t,normalized:r},p=w.runKernel(Lo,u,l);return o===1?T(p,[p.size]):p}const Al=y({multinomial_:Od});function Cd(n,e){let t=d(n,"a","notEqual","string_or_numeric"),r=d(e,"b","notEqual","string_or_numeric");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r};return w.runKernel(jo,s)}const Qr=y({notEqual_:Cd});function Fd(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:d(n,"indices","oneHot","int32")},i={dtype:s,depth:e,onValue:t,offValue:r};return w.runKernel(Go,o,i)}const Dl=y({oneHot_:Fd});function Rd(n){const t={x:d(n,"x","onesLike")};return w.runKernel(Ko,t)}const Ol=y({onesLike_:Rd});function Pd(n,e){const t=d(n,"v1","outerProduct"),r=d(e,"v2","outerProduct");g(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=T(t,[-1,1]),a=T(r,[1,-1]);return V(s,a)}const Cl=y({outerProduct_:Pd});function Bd(n,e,t=0){const r=d(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},a={x:r};return w.runKernel(Mo,a,s)}const _t=y({pad_:Bd});function Ld(n,e,t=0){return g(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),_t(n,[e],t)}const Fl=y({pad1d_:Ld});function zd(n,e,t=0){return g(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_t(n,e,t)}const Rl=y({pad2d_:zd});function Vd(n,e,t=0){return g(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_t(n,e,t)}const Pl=y({pad3d_:Vd});function jd(n,e,t=0){return g(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_t(n,e,t)}const Bl=y({pad4d_:jd});function qd(n,e,t){const r=d(n,"x","spaceToBatchND");g(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),g(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),g(r.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:t};return w.runKernel($i,s,a)}const Zr=y({spaceToBatchND_:qd});function Ud(n,e,t,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const i=d(n,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),g(Me(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const p=Rh(u.shape,e,a,s,r),h=[p.dilationHeight,p.dilationWidth];let m;r==="same"?m=Kd([p.filterHeight,p.filterWidth],h):m=[[0,0],[0,0]];const f=h[0]===1&&h[1]===1,[b,k]=Wd([p.inHeight,p.inWidth],h,m),N=f?r:"valid",S=f?u:Zr(u,h,b),I=(t==="avg"?()=>Rr(S,e,a,N,o):()=>Yr(S,e,a,N,o))(),v=f?I:Pr(I,h,k);return l?T(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function Wd(n,e,t){const r=t.map(p=>p[0]),s=t.map(p=>p[1]),a=n.concat(r,s),o=e.map((p,h)=>(p-a[h]%p)%p),i=s.map((p,h)=>p+o[h]),u=e.map((p,h)=>[r[h],i[h]]),l=e.map((p,h)=>[0,o[h]]);return[u,l]}function Kd(n,e){const r=n.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}const Ll=y({pool_:Ud});function Gd(n,e){const t=d(n,"x","prelu"),r=d(e,"alpha","prelu"),s={x:t,alpha:r};return w.runKernel(Yo,s)}const es=y({prelu_:Gd});function Hd(n,e=null,t=!1){let r=d(n,"x","prod");r.dtype==="bool"&&(r=G(r,"int32"));const s={x:r},a={axis:e,keepDims:t};return w.runKernel(Jo,s,a)}const zl=y({prod_:Hd});function Md(n,e,t,r){const s=n.map((p,h)=>d(p,`tensors${h}`,"raggedGather","int32")),a=d(e,"paramsDenseValues","raggedGather"),o=d(t,"indices","raggedGather","int32"),i={paramsNestedSplits:s,paramsDenseValues:a,indices:o},u={outputRaggedRank:r},l=w.runKernel(Qo,i,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const Vl=y({raggedGather_:Md});function Xd(n,e,t){const r=d(n,"starts","raggedRange"),s=d(e,"limits","raggedRange",r.dtype),a=d(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:a},i=w.runKernel(Zo,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const jl=y({raggedRange_:Xd});function Yd(n,e,t,r,s){const a=d(n,"shape","raggedTensorToTensor","int32"),o=d(e,"values","raggedTensorToTensor"),i=d(t,"defaultValue","raggedTensorToTensor",o.dtype),u=r.map((h,m)=>d(h,`tensors${m}`,"raggedTensorToTensor","int32")),l={shape:a,values:o,defaultValue:i,rowPartitionTensors:u},p={rowPartitionTypes:s};return w.runKernel(ei,l,p)}const ql=y({raggedTensorToTensor_:Yd});function Jd(n,e,t){me(n);const r=Y(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<r;a++)s[a]=e();return w.makeTensor(s,n,t)}const Ul=y({rand_:Jd});var rn={exports:{}},Qd=rn.exports,Os;function Zd(){return Os||(Os=1,(function(n){(function(e,t,r){function s(u){var l=this,p=i();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=p(" "),l.s1=p(" "),l.s2=p(" "),l.s0-=p(u),l.s0<0&&(l.s0+=1),l.s1-=p(u),l.s1<0&&(l.s1+=1),l.s2-=p(u),l.s2<0&&(l.s2+=1),p=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var p=new s(u),h=l&&l.state,m=p.next;return m.int32=function(){return p.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,h&&(typeof h=="object"&&a(h,p),m.state=function(){return a(p,{})}),m}function i(){var u=4022871197,l=function(p){p=String(p);for(var h=0;h<p.length;h++){u+=p.charCodeAt(h);var m=.02519603282416938*u;u=m>>>0,m-=u,m*=u,u=m>>>0,m-=u,u+=m*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:this.alea=o})(Qd,n)})(rn)),rn.exports}var sn={exports:{}},ef=sn.exports,Cs;function tf(){return Cs||(Cs=1,(function(n){(function(e,t,r){function s(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},i===(i|0)?u.x=i:l+=i;for(var p=0;p<l.length+64;p++)u.x^=l.charCodeAt(p)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new s(i),p=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var m=l.next()>>>11,f=(l.next()>>>0)/4294967296,b=(m+f)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,p&&(typeof p=="object"&&a(p,l),h.state=function(){return a(l,{})}),h}t&&t.exports?t.exports=o:this.xor128=o})(ef,n)})(sn)),sn.exports}var an={exports:{}},nf=an.exports,Fs;function rf(){return Fs||(Fs=1,(function(n){(function(e,t,r){function s(i){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var p=0;p<l.length+64;p++)u.x^=l.charCodeAt(p)|0,p==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new s(i),p=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var m=l.next()>>>11,f=(l.next()>>>0)/4294967296,b=(m+f)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,p&&(typeof p=="object"&&a(p,l),h.state=function(){return a(l,{})}),h}t&&t.exports?t.exports=o:this.xorwow=o})(nf,n)})(an)),an.exports}var on={exports:{}},sf=on.exports,Rs;function af(){return Rs||(Rs=1,(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var p=u.x,h=u.i,m,f;return m=p[h],m^=m>>>7,f=m^m<<24,m=p[h+1&7],f^=m^m>>>10,m=p[h+3&7],f^=m^m>>>3,m=p[h+4&7],f^=m^m<<7,m=p[h+7&7],m=m^m<<13,f^=m^m<<9,p[h]=f,u.i=h+1&7,f};function l(p,h){var m,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,m=0;m<h.length;++m)f[m&7]=f[m&7]<<15^h.charCodeAt(m)+f[m+1&7]<<13;for(;f.length<8;)f.push(0);for(m=0;m<8&&f[m]===0;++m);for(m==8?f[7]=-1:f[m],p.x=f,p.i=0,m=256;m>0;--m)p.next()}l(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),p=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var m=l.next()>>>11,f=(l.next()>>>0)/4294967296,b=(m+f)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,p&&(p.x&&a(p,l),h.state=function(){return a(l,{})}),h}t&&t.exports?t.exports=o:this.xorshift7=o})(sf,n)})(on)),on.exports}var un={exports:{}},of=un.exports,Ps;function uf(){return Ps||(Ps=1,(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var p=u.w,h=u.X,m=u.i,f,b;return u.w=p=p+1640531527|0,b=h[m+34&127],f=h[m=m+1&127],b^=b<<13,f^=f<<17,b^=b>>>15,f^=f>>>12,b=h[m]=b^f,u.i=m,b+(p^p>>>16)|0};function l(p,h){var m,f,b,k,N,S=[],x=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,x=Math.max(x,h.length)),b=0,k=-32;k<x;++k)h&&(f^=h.charCodeAt((k+32)%h.length)),k===0&&(N=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,k>=0&&(N=N+1640531527|0,m=S[k&127]^=f+N,b=m==0?b+1:0);for(b>=128&&(S[(h&&h.length||0)&127]=-1),b=127,k=512;k>0;--k)f=S[b+34&127],m=S[b=b+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,S[b]=f^m;p.w=N,p.X=S,p.i=b}l(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),p=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var m=l.next()>>>11,f=(l.next()>>>0)/4294967296,b=(m+f)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,p&&(p.X&&a(p,l),h.state=function(){return a(l,{})}),h}t&&t.exports?t.exports=o:this.xor4096=o})(of,n)})(un)),un.exports}var ln={exports:{}},lf=ln.exports,Bs;function cf(){return Bs||(Bs=1,(function(n){(function(e,t,r){function s(i){var u=this,l="";u.next=function(){var h=u.b,m=u.c,f=u.d,b=u.a;return h=h<<25^h>>>7^m,m=m-f|0,f=f<<24^f>>>8^b,b=b-h|0,u.b=h=h<<20^h>>>12^m,u.c=m=m-f|0,u.d=f<<16^m>>>16^b,u.a=b-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var p=0;p<l.length+20;p++)u.b^=l.charCodeAt(p)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new s(i),p=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var m=l.next()>>>11,f=(l.next()>>>0)/4294967296,b=(m+f)/(1<<21);while(b===0);return b},h.int32=l.next,h.quick=h,p&&(typeof p=="object"&&a(p,l),h.state=function(){return a(l,{})}),h}t&&t.exports?t.exports=o:this.tychei=o})(lf,n)})(ln)),ln.exports}var cn={exports:{}};const pf={},hf=Object.freeze(Object.defineProperty({__proto__:null,default:pf},Symbol.toStringTag,{value:"Module"})),mf=Zc(hf);var df=cn.exports,Ls;function ff(){return Ls||(Ls=1,(function(n){(function(e,t,r){var s=256,a=6,o=52,i="random",u=r.pow(s,a),l=r.pow(2,o),p=l*2,h=s-1,m;function f(v,E,_){var D=[];E=E==!0?{entropy:!0}:E||{};var O=S(N(E.entropy?[v,I(t)]:v??x(),3),D),C=new b(D),P=function(){for(var L=C.g(a),M=u,W=0;L<l;)L=(L+W)*s,M*=s,W=C.g(1);for(;L>=p;)L/=2,M/=2,W>>>=1;return(L+W)/M};return P.int32=function(){return C.g(4)|0},P.quick=function(){return C.g(4)/4294967296},P.double=P,S(I(C.S),t),(E.pass||_||function(L,M,W,X){return X&&(X.S&&k(X,C),L.state=function(){return k(C,{})}),W?(r[i]=L,M):L})(P,O,"global"in E?E.global:this==r,E.state)}function b(v){var E,_=v.length,D=this,O=0,C=D.i=D.j=0,P=D.S=[];for(_||(v=[_++]);O<s;)P[O]=O++;for(O=0;O<s;O++)P[O]=P[C=h&C+v[O%_]+(E=P[O])],P[C]=E;(D.g=function(L){for(var M,W=0,X=D.i,ae=D.j,de=D.S;L--;)M=de[X=h&X+1],W=W*s+de[h&(de[X]=de[ae=h&ae+M])+(de[ae]=M)];return D.i=X,D.j=ae,W})(s)}function k(v,E){return E.i=v.i,E.j=v.j,E.S=v.S.slice(),E}function N(v,E){var _=[],D=typeof v,O;if(E&&D=="object")for(O in v)try{_.push(N(v[O],E-1))}catch{}return _.length?_:D=="string"?v:v+"\0"}function S(v,E){for(var _=v+"",D,O=0;O<_.length;)E[h&O]=h&(D^=E[h&O]*19)+_.charCodeAt(O++);return I(E)}function x(){try{var v;return m&&(v=m.randomBytes)?v=v(s):(v=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(v)),I(v)}catch{var E=e.navigator,_=E&&E.plugins;return[+new Date,e,_,e.screen,I(t)]}}function I(v){return String.fromCharCode.apply(0,v)}if(S(r.random(),t),n.exports){n.exports=f;try{m=mf}catch{}}else r["seed"+i]=f})(typeof self<"u"?self:df,[],Math)})(cn)),cn.exports}var Vn,zs;function gf(){if(zs)return Vn;zs=1;var n=Zd(),e=tf(),t=rf(),r=af(),s=uf(),a=cf(),o=ff();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=r,o.xor4096=s,o.tychei=a,Vn=o,Vn}var ts=gf();class ns{constructor(e,t,r,s,a){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ts.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,a,o;do s=2*this.random()-1,a=2*this.random()-1,o=s*s+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class yf{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const a=s||Math.random();this.randu=ts.alea(a.toString()),this.randn=new ns(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,a,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<t||Math.log(a)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class bf{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=ts.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function wf(n,e,t=1,r="float32",s){if(me(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new yf(e,t,r,s),o=$e(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Wl=y({randomGamma_:wf});function Nf(n,e=0,t=1,r,s){if(me(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new ns(e,t,r,!1,s),o=$e(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const rs=y({randomNormal_:Nf});function kf(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return rs(n,0,1,e,t)}const Kl=y({randomStandardNormal_:kf});function Sf(n,e=0,t=1,r="float32",s){me(n);const a=$e(n,r),o=new bf(e,t,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const On=y({randomUniform_:Sf});function Tf(n,e,t,r){return On(n,e,t,"int32",r)}const Gl=y({randomUniformInt_:Tf});function St(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return w.runKernel(ti,{},s)}function vf(n){const t={input:d(n,"input","real")};return w.runKernel(ni,t)}const Tt=y({real_:vf});function $f(n){const t={x:d(n,"x","reciprocal")};return w.runKernel(ri,t)}const Hl=y({reciprocal_:$f});function Ef(n){const t={x:d(n,"x","relu")};return w.runKernel(si,t)}const Xt=y({relu_:Ef});function _f(n){const t={x:d(n,"x","relu6")};return w.runKernel(ui,t)}const ss=y({relu6_:_f});function xf(n,e){const r={x:d(n,"x","reverse")},s={dims:e};return w.runKernel(li,r,s)}const Ke=y({reverse_:xf});function If(n){const e=d(n,"x","reverse");return g(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ke(e,0)}const Ml=y({reverse1d_:If});function Af(n,e){const t=d(n,"x","reverse");return g(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Ke(t,e)}const Xl=y({reverse2d_:Af});function Df(n,e){const t=d(n,"x","reverse");return g(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Ke(t,e)}const Yl=y({reverse3d_:Df});function Of(n,e){const t=d(n,"x","reverse");return g(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Ke(t,e)}const Jl=y({reverse4d_:Of});function Cf(n){const t={x:d(n,"x","round")};return w.runKernel(ci,t)}const as=y({round_:Cf});function Ff(n){const t={x:d(n,"x","rsqrt","float32")};return w.runKernel(pi,t)}const Ql=y({rsqrt_:Ff});function Rf(n){const t={x:d(n,"x","selu")};return w.runKernel(gi,t)}const Zl=y({selu_:Rf});function Pf(n,e,t,r,s,a=[1,1],o="NHWC"){const i=d(n,"x","separableConv2d"),u=d(e,"depthwiseFilter","separableConv2d"),l=d(t,"pointwiseFilter","separableConv2d");let p=i,h=!1;if(i.rank===3&&(h=!0,p=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");g(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),g(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),g(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),g(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),g(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const m=u.shape[2],f=u.shape[3];g(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);const b=xn(p,u,r,s,o,a),N=Kt(b,l,1,"valid",o);return h?T(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const ec=y({separableConv2d_:Pf});async function Bf(n,e){const t=d(n,"x","setdiff1d"),r=d(e,"y","setdiff1d");g(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),g(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),g(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),a=await r.data(),o=new Set(a);let i=0;for(let p=0;p<s.length;p++)o.has(s[p])||i++;const u=new dn([i],t.dtype),l=new dn([i],"int32");for(let p=0,h=0;p<s.length;p++)o.has(s[p])||(u.values[h]=s[p],l.values[h]=p,h++);return[u.toTensor(),l.toTensor()]}const tc=Bf;function Lf(n){const t={x:d(n,"x","sign")};return w.runKernel(Ni,t)}const nc=y({sign_:Lf});function zf(n){const t={x:d(n,"x","sin","float32")};return w.runKernel(bi,t)}const rc=y({sin_:zf});function Vf(n){const t={x:d(n,"x","sinh")};return w.runKernel(wi,t)}const sc=y({sinh_:Vf});function jf(n,e,t){const r=d(n,"x","slice1d");return g(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),j(r,[e],[t])}const ac=y({slice1d_:jf});function qf(n,e,t){const r=d(n,"x","slice2d");return g(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),j(r,e,t)}const oc=y({slice2d_:qf});function Uf(n,e,t){const r=d(n,"x","slice3d");return g(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),j(r,e,t)}const ic=y({slice3d_:Uf});function Wf(n,e,t){const r=d(n,"x","slice4d");return g(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),j(r,e,t)}const uc=y({slice4d_:Wf});function Kf(n,e=-1){const t=d(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return w.runKernel(_i,r,s)}const os=y({softmax_:Kf});function Gf(n){g(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return w.runKernel(no,e)}const Cn=y({fft_:Gf});function Hf(n){g(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return w.runKernel(ho,e)}const qt=y({ifft_:Hf});function Mf(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=T(n,[t,e]);r=qt(s)}else{const s=[t,2*(e-1)],a=T(Tt(n),[t,e]),o=T(Mt(n),[t,e]),i=Ke(j(a,[0,1],[t,e-2]),1),u=$(Ke(j(o,[0,1],[t,e-2]),1),B(-1)),l=te([a,i],1),p=te([o,u],1),h=T(Be(l,p),[s[0],s[1]]);r=qt(h)}if(r=Tt(r),n.rank===3&&n.shape[0]!==0){const s=r,a=n.shape[0];r=T(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const is=y({irfft_:Mf});function Xf(n,e,t=0){const s={x:d(n,"x","split")},a={numOrSizeSplits:e,axis:t};return w.runKernel(Ei,s,a)}const vt=y({split_:Xf});function Yf(n,e){g(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const b=n.shape.map(N=>0),k=n.shape.map(N=>N);k[n.shape.length-1]=e,s=j(n,b,k),t=e}else if(e!=null&&e>t){const b=n.shape.map(k=>k);b[n.shape.length-1]=e-t,s=te([n,We(b)],n.shape.length-1),t=e}else s=n;const a=pe(s),o=T(Be(s,a),[r,t]),i=Cn(o),u=Math.floor(t/2)+1,l=Tt(i),p=Mt(i),h=vt(l,[u,t-u],l.shape.length-1),m=vt(p,[u,t-u],p.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=u,T(Be(h[0],m[0]),f)}const Fn=y({rfft_:Yf});function Jf(n,e){let t=d(n,"a","squaredDifference"),r=d(e,"b","squaredDifference");[t,r]=H(t,r),J(t.shape,r.shape);const s={a:t,b:r},a={};return w.runKernel(Ci,s,a)}const us=y({squaredDifference_:Jf});function Qf(n,e){const t=d(n,"x","squeeze","string_or_numeric");return T(t,rp(t.shape,e).newShape)}const Yt=y({squeeze_:Qf});function Zf(n,e=0){const t=fn(n,"tensors","stack","string_or_numeric");g(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&g(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return w.runKernel(Ho,r,s)}const xe=y({stack_:Zf});function eg(n,e=0){const r={x:d(n,"x","step")},s={alpha:e};return w.runKernel(Mi,r,s)}const ls=y({step_:eg});function tg(n,e,t,r,s=0,a=0,o=0,i=0,u=0){const p={x:d(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return w.runKernel(Ri,p,h)}const lc=y({stridedSlice_:tg});function ng(n){const t={x:d(n,"x","tan","float32")};return w.runKernel(Vi,t)}const cc=y({tan_:ng});function he(n,e){$t(n);const t=Ge(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return He(n,null,t,e)}function yt(n,e,t){if($t(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Ge(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return He(n,e,r,t)}function cs(n,e,t){if($t(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Ge(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return He(n,e,r,t)}function pc(n,e,t){if($t(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Ge(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return He(n,e,r,t)}function hc(n,e,t){if($t(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Ge(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return He(n,e,r,t)}function mc(n,e,t){if($t(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Ge(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,He(n,e,r,t)}function rg(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(a+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(a+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(a+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(a+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function dc(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}rg(t,e,n)}function sg(n,e,t){const r=d(n,"tensor","tensorScatterupdate"),s=d(e,"indices","tensorScatterupdate","int32"),a=d(t,"updates","tensorScatterupdate");if(dc(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const o={tensor:r,indices:s,updates:a},i={};return w.runKernel(mi,o,i)}const fc=y({tensorScatterUpdate_:sg});function ag(n,e=1,t=!0){const r=d(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},o={k:e,sorted:t},[i,u]=w.runKernel(qi,a,o);return{values:i,indices:u}}const gc=y({topk_:ag});function og(n,e=0,t=1,r,s){if(me(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new ns(e,t,r,!0,s),o=$e(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const yc=y({truncatedNormal_:og});function ig(n,e=0){const t=d(n,"x","unique","string_or_numeric");g(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[a,o]=w.runKernel(Wi,r,s);return{values:a,indices:o}}const bc=y({unique_:ig});function ug(n,e,t){const r=d(n,"x","unsortedSegmentSum"),s=d(e,"segmentIds","unsortedSegmentSum","int32");g(Rt(t),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},o={numSegments:t};return w.runKernel(Gi,a,o)}const wc=y({unsortedSegmentSum_:ug});function lg(n,e=0){const t=d(n,"x","unstack","string_or_numeric");g(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return w.runKernel(Ki,r,s)}const Xe=y({unstack_:lg});function Nc(n,e){return Dn(n,e,"right")}function kc(n,e=!0,t,r){return w.makeVariable(n,e,t,r)}function cg(n,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const r=$e(n,"int32"),s=$e([t.length,n.length],"int32");for(let a=0;a<t.length;a++){const o=r.indexToLoc(t[a]),i=a*n.length;s.values.set(o,i)}return s.toTensor()}async function pg(n){const e=d(n,"condition","whereAsync","bool"),t=await e.data(),r=cg(e.shape,t);return n!==e&&e.dispose(),r}const ps=pg;async function hg(n,e,t){const r=d(n,"tensor","boolMask"),s=d(e,"mask","boolMask","bool"),a=t??0,o=s.rank,i=r.shape;g(o>0,()=>"mask cannot be scalar"),be(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let k=a;k<a+o;k++)u*=i[k];const l=i.slice(0,a).concat([u],i.slice(a+o)),p=T(r,l),h=T(s,[-1]),m=await ps(h),f=Yt(m,[1]),b=qr(p,f,a);return n!==r&&r.dispose(),e!==s&&s.dispose(),f.dispose(),p.dispose(),h.dispose(),m.dispose(),b}const Sc=hg;function mg(n,e,t){const r=d(n,"x","transpose");if(e==null&&(e=r.shape.map((o,i)=>i).reverse()),g(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{g(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?z(()=>{let o=Tt(r),i=Mt(r);return o=w.runKernel(en,{x:o},a),i=w.runKernel(en,{x:i},a),t&&(i=Se(i)),Be(o,i)}):w.runKernel(en,s,a)}const kn=y({transpose_:mg});function dg(n,e,t,r,s=!0){const a=d(n,"v","movingAverage"),o=d(e,"x","movingAverage"),i=d(t,"decay","movingAverage");Ip(a,o),g(Pe(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=B(1),l=F(u,i);let p=$(F(o,a),l);if(s){g(r!=null,()=>"When using zeroDebias: true, step is required.");const h=d(r,"step","movingAverage");p=U(p,F(u,Nt(i,h)))}return A(a,p)}const Tc=y({movingAverage_:dg});function fg(n,e,t){me(t);const r=d(n,"indices","scatterND","int32"),s=d(e,"updates","scatterND");dc(s,r,t);const a={indices:r,updates:s},o={shape:t};return w.runKernel(hi,a,o)}const vc=y({scatterND_:fg});function gg(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,a=n.rank>1?n.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function yg(n,e,t,r=0){me(t);const s=d(n,"sparseIndices","sparseToDense","int32"),a=d(e,"sparseValues","sparseToDense","string_or_numeric"),o=d(r,"defaultValue","sparseToDense",a.dtype);gg(s,a,t,o);const i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:t};return w.runKernel(Oi,i,u)}const $c=y({sparseToDense_:yg});function bg(n,e){const t=d(e,"indices","gatherND","int32"),s={params:d(n,"x","gatherND","string_or_numeric"),indices:t};return w.runKernel(lo,s)}const Ec=y({gatherND_:bg});function wg(n,e){if(e==null)return n.shape.slice();if(Pe(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}function Ng(n,e,t,r){const s=d(n,"x","dropout");if(g(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),g(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Q?s.clone():s;const a=wg(s,t),o=1-e,i=U(jr(A(On(a,0,1,"float32",r),o)),o);return $(s,i)}const _c=y({dropout_:Ng});function hs(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Rn(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let a=0;a<n;++a){const o=2*Math.PI*a/(n+r-1);s[a]=e-t*Math.cos(o)}return he(s,"float32")}async function kg(n,e,t=1){const r=d(n,"predictions","inTopK"),s=d(e,"targets","inTopK");g(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),g(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),be(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];g(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const o=await r.data(),i=await s.data(),[u,l]=[o.length/a,a],p=sp("bool",u);for(let h=0;h<u;h++){const m=h*l,f=o.subarray(m,m+l),b=[];for(let k=0;k<f.length;k++)b.push({value:f[k],index:k});b.sort((k,N)=>N.value-k.value),p[h]=0;for(let k=0;k<t;k++)if(b[k].index===i[h]){p[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),ke(p,s.shape,"bool")}const xc=kg;function Sg(n,e,t,r,s,a="NHWC",o){let i=n;n.rank===3&&(i=T(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=T(e,[1,e.shape[0],e.shape[1],e.shape[2]])),g(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),g(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),g(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],p=a==="NHWC"?u.shape[3]:u.shape[1];g(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),g(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),ve("conv2dDerFilter",s,o);const h={x:i,dy:u},m={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:t};return w.runKernel(Oa,h,m)}const Tg=y({conv2DBackpropFilter_:Sg});function ms(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return $(n,ls(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ds(n,e){let t=e;const r=_m(n.shape,e.shape);return r.length>0&&(t=q(t,r)),T(t,n.shape)}function fs(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Xt(n);if(e==="elu")return zr(n);if(e==="relu6")return ss(n);if(e==="prelu")return es(n,t);if(e==="leakyrelu")return Wr(n,r);if(e==="sigmoid")return nt(n);throw new Error(`Unknown fused activation ${e}.`)}const gs=(n,e)=>!(n>0)||e==="linear";function vg({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(u=u||"linear",gs(w.state.gradientDepth,u)===!1){g(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=Kt(n,e,t,r,s,a,o);return i!=null&&(_=A(_,i)),fs(_,u,l,p)}const h=d(n,"x","conv2d","float32"),m=d(e,"filter","conv2d","float32");let f=h,b=!1;h.rank===3&&(b=!0,f=T(h,[1,h.shape[0],h.shape[1],h.shape[2]])),g(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),g(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),ve("fused conv2d",r,o);const k=s==="NHWC"?f.shape[3]:f.shape[1];g(m.shape[2]===k,()=>`Error in conv2d: depth of input (${k}) must match input depth for filter ${m.shape[2]}.`),g(Me(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const N=Fr(f.shape,m.shape,t,a,r,o);let S;i!=null&&(S=d(i,"bias","fused conv2d"),[S]=H(S,h),s==="NHWC"?J(N.outShape,S.shape):(g(S.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`),g(S.shape.length===0||S.shape[0]===N.outChannels||S.shape[0]===1,()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${N.outChannels})`)));let x;if(l!=null){const _=l.shape;if(g(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)g(_[0]===1||_[0]===N.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${N.outChannels}).`);else if(_.length===3)try{J(_,N.outShape)}catch{const O=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(O)}x=d(l,"prelu weights","fused conv2d")}const I=(_,D)=>{g(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[O,C,P,L]=D,M=ms(_,P,u);g(yn(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const W=Mu(C.shape,M,O,t,r),X=Tg(C,M,O.shape,t,r),ae=[W,X];if(L!=null){const de=ds(L,M);ae.push(de)}return ae},v={x:f,filter:m,bias:S,preluActivationWeights:x},E={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:p};return i==null?_e((D,O,C)=>{let P=w.runKernel(Mn,v,E);return C([O,D,P]),b&&(P=T(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:I}})(f,m):_e((D,O,C,P)=>{let L=w.runKernel(Mn,v,E);return P([O,D,L,C]),b&&(L=T(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:I}})(f,m,S)}const $g=y({fusedConv2d_:vg});function Eg(n,e,t,r,s,a=[1,1],o){let i=n;n.rank===3&&(i=T(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},p={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:t};return w.runKernel(Wa,l,p)}const _g=y({depthwiseConv2dNativeBackpropFilter_:Eg});function xg(n,e,t,r,s,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:t},p={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:n},h=w.runKernel(Ka,l,p);return u?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ig=y({depthwiseConv2dNativeBackpropInput_:xg});function Ag({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(gs(w.state.gradientDepth,u)===!1){let E=xn(n,e,t,r,s,a,o);return i!=null&&(E=A(E,i)),fs(E,u,l,p)}const h=d(n,"x","depthwiseConv2d","float32"),m=d(e,"filter","depthwiseConv2d","float32");let f=h,b=!1;h.rank===3&&(b=!0,f=T(h,[1,h.shape[0],h.shape[1],h.shape[2]])),g(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),g(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),g(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),a==null&&(a=[1,1]),g(Me(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ve("fused depthwiseConv2d",r,o);const k=Fr(f.shape,m.shape,t,a,r,o,!0);let N;i!=null&&(N=d(i,"bias","fused conv2d"),[N]=H(N,h),J(k.outShape,N.shape));let S;l!=null&&(S=d(l,"prelu weights","fused depthwiseConv2d"));const x=(E,_)=>{g(yn(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[D,O,C,P]=_,L=ms(E,C,u),M=Ig(O.shape,L,D,t,r,a,o),W=_g(O,L,D.shape,t,r,a,o);if(P!=null){const X=ds(N,L);return[M,W,X]}return[M,W]},I={x:f,filter:m,bias:N,preluActivationWeights:S},v={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:p};return i==null?_e((_,D,O)=>{let C=w.runKernel(Xn,I,v);return O([D,_,C]),b&&(C=T(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:x}})(f,m):_e((_,D,O,C)=>{let P=w.runKernel(Xn,I,v);return C([D,_,P,O]),b&&(P=T(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:x}})(f,m,N)}const Dg=y({fusedDepthwiseConv2d_:Ag});function Og({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(gs(w.state.gradientDepth,a)===!1){let L=V(n,e,t,r);return s!=null&&(L=A(L,s)),fs(L,a,o,i)}let u=d(n,"a","fused matMul"),l=d(e,"b","fused matMul");[u,l]=H(u,l);const p=t?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],f=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=u.shape.slice(0,-2),k=l.shape.slice(0,-2),N=Y(b),S=Y(k);g(p===h,()=>`Error in fused matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const I=J(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,f]),v=t?T(u,[N,p,m]):T(u,[N,m,p]),E=r?T(l,[S,f,h]):T(l,[S,h,f]);let _;s!=null&&(_=d(s,"bias","fused matMul"),[_]=H(_,u),J(I,_.shape));let D;o!=null&&(D=d(o,"prelu weights","fused matMul"));const O=(L,M)=>{const[W,X,ae,de]=M,Ie=ms(T(L,ae.shape),ae,a);let ct,pt;if(!t&&!r?(ct=V(Ie,X,!1,!0),pt=V(W,Ie,!0,!1)):!t&&r?(ct=V(Ie,X,!1,!1),pt=V(Ie,W,!0,!1)):t&&!r?(ct=V(X,Ie,!1,!0),pt=V(W,Ie,!1,!1)):(ct=V(X,Ie,!0,!0),pt=V(Ie,W,!0,!0)),s!=null){const Qc=ds(de,Ie);return[ct,pt,Qc]}else return[ct,pt]},C={a:v,b:E,bias:_,preluActivationWeights:D},P={transposeA:t,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?_e((M,W,X)=>{const ae=w.runKernel(Hn,C,P);return X([M,W,ae]),{value:T(ae,I),gradFunc:O}})(v,E):_e((M,W,X,ae)=>{const de=w.runKernel(Hn,C,P);return ae([M,W,de,X]),{value:T(de,I),gradFunc:O}})(v,E,_)}const Cg=y({fusedMatMul_:Og});const Ic=Object.freeze(Object.defineProperty({__proto__:null,conv2d:$g,depthwiseConv2d:Dg,matMul:Cg},Symbol.toStringTag,{value:"Module"}));function Fg(n){return Rn(n,.54,.46)}const Rg=y({hammingWindow_:Fg});function Pg(n){return Rn(n,.5,.5)}const Ac=y({hannWindow_:Pg});function Bg(n,e,t,r=!1,s=0){let a=0;const o=[];for(;a+e<=n.size;)o.push(j(n,a,e)),a+=t;if(r)for(;a<n.size;){const i=a+e-n.size,u=te([j(n,a,e-i),Et([i],s)]);o.push(u),a+=t}return o.length===0?yt([],[0,e]):T(te(o),[o.length,e])}const Dc=y({frame_:Bg});function Lg(n,e,t,r,s=Ac){r==null&&(r=hs(e));const a=Dc(n,e,t),o=$(a,s(e));return Fn(o,r)}const zg=y({stft_:Lg});function Vg(n,e,t,r,s="bilinear",a=0){const o=d(n,"image","cropAndResize"),i=d(e,"boxes","cropAndResize","float32"),u=d(t,"boxInd","cropAndResize","int32"),l=i.shape[0];g(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),g(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),g(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),g(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),g(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),g(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const p={image:o,boxes:i,boxInd:u},h={method:s,extrapolationValue:a,cropSize:r};return w.runKernel(Va,p,h)}const jg=y({cropAndResize_:Vg});function qg(n){const e=d(n,"image","flipLeftRight","float32");g(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return w.runKernel(so,t,{})}const Ug=y({flipLeftRight_:qg});function Wg(n){const e=d(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];g(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),g(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,gt(e,s)}const Kg=y({grayscaleToRGB_:Wg});function Gg(n){const e=d(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];g(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),g(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,a=G(e,"float32"),o=he([.2989,.587,.114]);let i;switch(e.rank){case 2:i=Qe("ij,j->i",a,o);break;case 3:i=Qe("ijk,k->ij",a,o);break;case 4:i=Qe("ijkl,l->ijk",a,o);break;case 5:i=Qe("ijklm,m->ijkl",a,o);break;case 6:i=Qe("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=Ae(i,-1),G(i,s)}const Hg=y({rgbToGrayscale_:Gg});function Mg(n,e,t=0,r=.5){const s=d(n,"image","rotateWithOffset","float32");g(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},o={radians:e,fillValue:t,center:r};return w.runKernel(Xi,a,o)}const Xg=y({rotateWithOffset_:Mg});function xt(n,e,t,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=n.shape[0];return t=Math.min(t,o),g(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),g(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),g(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),g(e.rank===1,()=>"scores must be a 1D tensor"),g(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),g(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function Yg(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const a=d(n,"boxes","nonMaxSuppression","float32"),o=d(e,"scores","nonMaxSuppression","float32"),i=xt(a,o,t,r,s);t=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return w.runKernel(qo,{boxes:a,scores:o},u)}const Jg=y({nonMaxSuppression_:Yg});function Qg(n,e,t){const r=Zg(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function Zg(n,e,t){return ty(n,e,t||ey)}function ey(n,e){return n>e?1:n<e?-1:0}function ty(n,e,t){let r=0,s=n.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=t(e,n[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}function ny(n,e,t,r,s){return ys(n,e,t,r,s,0)}function ry(n,e,t,r,s,a){return ys(n,e,t,r,s,0,!1,a,!0)}function sy(n,e,t,r,s,a){return ys(n,e,t,r,s,a,!0)}function ys(n,e,t,r,s,a,o=!1,i=!1,u=!1){const l=[];for(let N=0;N<e.length;N++)e[N]>s&&l.push({score:e[N],boxIndex:N,suppressBeginIndex:0});l.sort(Vs);const p=a>0?-.5/a:0,h=[],m=[];for(;h.length<t&&l.length>0;){const N=l.pop(),{score:S,boxIndex:x,suppressBeginIndex:I}=N;if(S<s)break;let v=!1;for(let E=h.length-1;E>=I;--E){const _=ay(n,x,h[E]);if(_>=r){v=!0;break}if(N.score=N.score*oy(r,p,_),N.score<=s)break}N.suppressBeginIndex=h.length,v||(N.score===S?(h.push(x),m.push(N.score)):N.score>s&&Qg(l,N,Vs))}const f=h.length,b=t-f;i&&b>0&&(h.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const k={selectedIndices:h};return o&&(k.selectedScores=m),u&&(k.validOutputs=f),k}function ay(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),p=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),m=Math.max(s[1],s[3]),f=(i-a)*(u-o),b=(h-l)*(m-p);if(f<=0||b<=0)return 0;const k=Math.max(a,l),N=Math.max(o,p),S=Math.min(i,h),x=Math.min(u,m),I=Math.max(S-k,0)*Math.max(x-N,0);return I/(f+b-I)}function oy(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function Vs(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function iy(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const a=d(n,"boxes","nonMaxSuppressionAsync"),o=d(e,"scores","nonMaxSuppressionAsync"),i=xt(a,o,t,r,s);t=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u=await Promise.all([a.data(),o.data()]),l=u[0],p=u[1],{selectedIndices:h}=ny(l,p,t,r,s);return a!==n&&a.dispose(),o!==e&&o.dispose(),he(h,"int32")}const uy=iy;function ly(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=d(n,"boxes","nonMaxSuppression"),i=d(e,"scores","nonMaxSuppression"),u=xt(o,i,t,r,s,a);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:o,scores:i},p={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},h=w.runKernel(Wo,l,p);return{selectedIndices:h[0],selectedScores:h[1]}}const cy=y({nonMaxSuppressionWithScore_:ly});async function py(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=d(n,"boxes","nonMaxSuppressionAsync"),i=d(e,"scores","nonMaxSuppressionAsync"),u=xt(o,i,t,r,s,a);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),p=l[0],h=l[1],{selectedIndices:m,selectedScores:f}=sy(p,h,t,r,s,a);return o!==n&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:he(m,"int32"),selectedScores:he(f)}}const hy=py;function my(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=d(n,"boxes","nonMaxSuppression"),i=d(e,"scores","nonMaxSuppression"),u=xt(o,i,t,r,s,null),l=u.maxOutputSize,p=u.iouThreshold,h=u.scoreThreshold,m={boxes:o,scores:i},f={maxOutputSize:l,iouThreshold:p,scoreThreshold:h,padToMaxOutputSize:a},b=w.runKernel(Uo,m,f);return{selectedIndices:b[0],validOutputs:b[1]}}const dy=y({nonMaxSuppressionPadded_:my});async function fy(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=d(n,"boxes","nonMaxSuppressionAsync"),i=d(e,"scores","nonMaxSuppressionAsync"),u=xt(o,i,t,r,s,null),l=u.maxOutputSize,p=u.iouThreshold,h=u.scoreThreshold,[m,f]=await Promise.all([o.data(),i.data()]),{selectedIndices:b,validOutputs:k}=ry(m,f,l,p,h,a);return o!==n&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:he(b,"int32"),validOutputs:B(k,"int32")}}const gy=fy;function yy(n,e,t=!1,r=!1){const s=d(n,"images","resizeBilinear");g(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),g(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),g(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=T(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:r,size:e},l=w.runKernel(ii,i,u);return o?T(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const by=y({resizeBilinear_:yy});function wy(n,e,t=!1,r=!1){const s=d(n,"images","resizeNearestNeighbor");g(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),g(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),g(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),g(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=T(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:r,size:e},l=w.runKernel(oi,i,u);return o?T(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Ny=y({resizeNearestNeighbor_:wy});function ky(n,e="binary",t=!1,r=.5){const s=d(n,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1];let l=$(he([r]),255),p,h,m,f;if(g(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),g(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),g(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),g(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[p,h,m]=vt(s,[1,1,1],-1);const N=$(p,a),S=$(h,o),x=$(m,i);f=A(A(N,S),x)}else f=n;if(e==="otsu"){const N=Br(G(as(f),"int32"),ke([]),256);l=Sy(N,u)}const b=t?An(f,l):Ht(f,l);return G($(b,255),"int32")}function Sy(n,e){let t=he([-1]),r=he([0]),s=he([0]),a,o,i,u,l,p;for(let h=0;h<n.size-1;h++){a=j(n,0,h+1),o=j(n,h+1),l=U(q(a),e),p=U(q(o),e);const m=q($(a,St(0,a.size)));i=U(m,q(a));const f=Et(o.shape,a.size),b=A(St(0,o.size),f),k=$(o,b);u=U(q(k),q(o));const N=F(i,u),S=F(i,u),x=$(l,p);s=$($(x,N),S);const I=Ht(s,r);r=Re(I,s,r),t=Re(I,he([h]),t)}return t}const Ty=y({threshold_:ky});function vy(n,e,t="nearest",r="constant",s=0,a){const o=d(n,"image","transform","float32"),i=d(e,"transforms","transform","float32");g(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),g(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),g(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},l={interpolation:t,fillMode:r,fillValue:s,outputShape:a};return w.runKernel(Ui,u,l)}const $y=y({transform_:vy});function Ey(n,e,t){const r=d(n,"a","bandPart");g(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,o]=r.shape.slice(-2);let i,u;typeof e=="number"?(g(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),g(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),i=d(e<0?a:e,"numLower","bandPart")):(g(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=Re(Nn(e,0),a,jt(e,a))),typeof t=="number"?(g(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),g(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),u=d(t<0?o:t,"numUpper","bandPart")):(g(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Re(Nn(t,0),o,jt(t,o)));const l=T(St(0,a,1,"int32"),[-1,1]),p=St(0,o,1,"int32"),h=F(l,p),m=zt(An(h,i),Ur(h,Se(u))),f=We([a,o],r.dtype);return T(xe(Xe(T(r,[-1,a,o])).map(b=>Re(m,b,f))),s)}const _y=y({bandPart_:Ey});function xy(n){let e;if(Array.isArray(n)){e=!1,g(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let a=1;a<n.length;++a)g(n[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${s})`)}else e=!0,n=vt(n,n.shape[0],0).map(s=>Yt(s,[0]));g(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(w.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){const i=$(q($(t[o],a)),t[o]);a=F(a,i)}return U(a,Gt(a,"euclidean"))}));return e?xe(t,0):t}const Iy=y({gramSchmidt_:xy});function Ay(n,e=!1){if(g(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return js(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),r=Xe(T(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[l,p]=js(u,e);s.push(l),a.push(p)});const o=T(xe(s,0),n.shape),i=T(xe(a,0),n.shape);return[o,i]}}function js(n,e=!1){return w.tidy(()=>{g(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=Vr(t),a=Fe(n);const o=yt([[1]],[1,1]);let i=Fe(o);const u=t>=r?r:t;for(let l=0;l<u;++l){const p=a,h=i,m=s;[i,a,s]=w.tidy(()=>{const f=j(a,[l,l],[t-l,1]),b=Gt(f),k=j(a,[l,l],[1,1]),N=Re(Ht(k,0),yt([[-1]]),yt([[1]])),S=F(k,$(N,b)),x=U(f,S);x.shape[0]===1?i=Fe(o):i=te([o,j(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const I=Se(U(V(N,S),b)),v=j(a,[l,0],[t-l,r]),E=$(I,i),_=kn(i);if(l===0)a=F(v,V(E,V(_,v)));else{const C=F(v,V(E,V(_,v)));a=te([j(a,[0,0],[l,r]),C],0)}const D=kn(E),O=j(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=F(O,V(V(O,i),D));else{const C=F(O,V(V(O,i),D));s=te([j(s,[0,0],[t,l]),C],1)}return[i,a,s]}),se([p,h,m])}return!e&&t>r&&(s=j(s,[0,0],[t,r]),a=j(a,[0,0],[r,r])),[s,a]})}const Dy=y({qr_:Ay});var re;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(re||(re={}));function Oy(n,e,t=re.SUM_BY_NONZERO_WEIGHTS){const r=d(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=d(e,"weights","computeWeightedLoss"));const a=s==null?r:$(r,s);if(t===re.NONE)return a;if(t===re.SUM)return q(a);if(t===re.MEAN){if(s==null)return Vt(a);{const o=r.size/s.size,i=U(q(a),q(s));return o>1?U(i,B(o)):i}}if(t===re.SUM_BY_NONZERO_WEIGHTS){if(s==null)return U(q(a),B(r.size));{const o=$(s,je(r.shape)),i=G(q(Qr(o,B(0))),"float32");return U(q(a),i)}}throw Error(`Unknown reduction: ${t}`)}const Le=y({computeWeightedLoss_:Oy});function Cy(n,e,t,r=re.SUM_BY_NONZERO_WEIGHTS){const s=d(n,"labels","absoluteDifference"),a=d(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=d(t,"weights","absoluteDifference")),be(s.shape,a.shape,"Error in absoluteDifference: ");const i=ce(F(s,a));return Le(i,o,r)}const Fy=y({absoluteDifference_:Cy});function Ry(n,e,t,r,s=re.SUM_BY_NONZERO_WEIGHTS){const a=d(n,"labels","cosineDistance"),o=d(e,"predictions","cosineDistance");let i=null;r!=null&&(i=d(r,"weights","cosineDistance")),be(a.shape,o.shape,"Error in cosineDistance: ");const u=B(1),l=F(u,q($(a,o),t,!0));return Le(l,i,s)}const Py=y({cosineDistance_:Ry});function By(n,e,t,r=re.SUM_BY_NONZERO_WEIGHTS){let s=d(n,"labels","hingeLoss");const a=d(e,"predictions","hingeLoss");let o=null;t!=null&&(o=d(t,"weights","hingeLoss")),be(s.shape,a.shape,"Error in hingeLoss: ");const i=B(1);s=F($(B(2),s),i);const u=Xt(F(i,$(s,a)));return Le(u,o,r)}const Ly=y({hingeLoss_:By});function zy(n,e,t,r=1,s=re.SUM_BY_NONZERO_WEIGHTS){const a=d(n,"labels","huberLoss"),o=d(e,"predictions","huberLoss");let i=null;t!=null&&(i=d(t,"weights","huberLoss")),be(a.shape,o.shape,"Error in huberLoss: ");const u=B(r),l=ce(F(o,a)),p=jt(l,u),h=F(l,p),m=A($(B(.5),ge(p)),$(u,h));return Le(m,i,s)}const Vy=y({huberLoss_:zy});function jy(n,e,t,r=1e-7,s=re.SUM_BY_NONZERO_WEIGHTS){const a=d(n,"labels","logLoss"),o=d(e,"predictions","logLoss");let i=null;t!=null&&(i=d(t,"weights","logLoss")),be(a.shape,o.shape,"Error in logLoss: ");const u=B(1),l=B(r),p=Se($(a,kt(A(o,l)))),h=$(F(u,a),kt(A(F(u,o),l))),m=F(p,h);return Le(m,i,s)}const qy=y({logLoss_:jy});function Uy(n,e,t,r=re.SUM_BY_NONZERO_WEIGHTS){const s=d(n,"labels","meanSquaredError"),a=d(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=d(t,"weights","meanSquaredError")),be(s.shape,a.shape,"Error in meanSquaredError: ");const i=us(s,a);return Le(i,o,r)}const Wy=y({meanSquaredError_:Uy});function Ky(n,e){const t=d(n,"labels","sigmoidCrossEntropyWithLogits"),r=d(e,"logits","sigmoidCrossEntropyWithLogits");be(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Xt(r),a=$(r,t),o=Kr(Ue(Se(ce(r))));return A(F(s,a),o)}function Gy(n,e,t,r=0,s=re.SUM_BY_NONZERO_WEIGHTS){let a=d(n,"multiClassLabels","sigmoidCrossEntropy");const o=d(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=d(t,"weights","sigmoidCrossEntropy")),be(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=B(r),p=B(1),h=B(.5);a=A($(a,F(p,l)),$(h,l))}const u=Ky(a,o);return Le(u,i,s)}const Hy=y({sigmoidCrossEntropy_:Gy});function My(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return _e((s,a,o)=>{const u=Hr(a,[t],!0),l=F(G(a,"float32"),u);o([s,l]);const p=Se($(l,s));return{value:q(p,[t]),gradFunc:(f,b)=>{const[k,N]=b,S=In(f.shape,[t]);return[$(T(f,S),F(G(k,"float32"),Ue(N))),$(T(f,S),F(Ue(N),G(k,"float32")))]}}})(n,e)}function Xy(n,e,t,r=0,s=re.SUM_BY_NONZERO_WEIGHTS){let a=d(n,"onehotLabels","softmaxCrossEntropy");const o=d(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=d(t,"weights","softmaxCrossEntropy")),be(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=B(r),p=B(1),h=B(a.shape[1]);a=A($(a,F(p,l)),U(l,h))}const u=My(a,o);return Le(u,i,s)}const Yy=y({softmaxCrossEntropy_:Xy});function Jy(n,e,t,r){const s=d(n,"indices","sparseFillEmptyRows","int32"),a=d(e,"values","sparseFillEmptyRows"),o=d(t,"denseShape","sparseFillEmptyRows","int32"),i=d(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:a,denseShape:o,defaultValue:i},l=w.runKernel(xi,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const Qy=y({sparseFillEmptyRows_:Jy});function Zy(n,e,t){const r=d(n,"inputIndices","sparseReshape","int32"),s=d(e,"inputShape","sparseReshape","int32"),a=d(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:r,inputShape:s,newShape:a},i=w.runKernel(Ii,o);return{outputIndices:i[0],outputShape:i[1]}}const eb=y({sparseReshape_:Zy});function tb(n,e,t){const r=d(n,"data","sparseSegmentMean"),s=d(e,"indices","sparseSegmentMean","int32"),a=d(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return w.runKernel(Ai,o)}const nb=y({sparseSegmentMean_:tb});function rb(n,e,t){const r=d(n,"data","sparseSegmentSum"),s=d(e,"indices","sparseSegmentSum","int32"),a=d(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return w.runKernel(Di,o)}const sb=y({sparseSegmentSum_:rb});function ab(n,e,t,r,s,a,o,i){const u=d(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=d(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const p={separator:t,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:u,dataSplits:l},m=w.runKernel(Pi,h,p);return{nGrams:m[0],nGramsSplits:m[1]}}const ob=y({stringNGrams_:ab});function ib(n,e,t=!0){const r=d(n,"input","stringSplit","string"),s=d(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:t},o={input:r,delimiter:s},i=w.runKernel(Bi,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const ub=y({stringSplit_:ib});function lb(n,e){const t=d(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return w.runKernel(Li,s,r)}const cb=y({stringToHashBucketFast_:lb});function pb(n,e,t,r=!0){const s=d(n,"input","staticRegexReplace","string"),a={pattern:e,rewrite:t,replaceGlobal:r};return w.runKernel(Fi,{x:s},a)}const hb=y({staticRegexReplace_:pb});const Oc={fft:Cn,ifft:qt,rfft:Fn,irfft:is},Cc={hammingWindow:Rg,hannWindow:Ac,frame:Dc,stft:zg},bs={flipLeftRight:Ug,grayscaleToRGB:Kg,resizeNearestNeighbor:Ny,resizeBilinear:by,rgbToGrayscale:Hg,rotateWithOffset:Xg,cropAndResize:jg,nonMaxSuppression:Jg,nonMaxSuppressionAsync:uy,nonMaxSuppressionWithScore:cy,nonMaxSuppressionWithScoreAsync:hy,nonMaxSuppressionPadded:dy,nonMaxSuppressionPaddedAsync:gy,threshold:Ty,transform:$y},Fc={bandPart:_y,gramSchmidt:Iy,qr:Dy},Rc={absoluteDifference:Fy,computeWeightedLoss:Le,cosineDistance:Py,hingeLoss:Ly,huberLoss:Vy,logLoss:qy,meanSquaredError:Wy,sigmoidCrossEntropy:Hy,softmaxCrossEntropy:Yy},Pc={sparseFillEmptyRows:Qy,sparseReshape:eb,sparseSegmentMean:nb,sparseSegmentSum:sb},Bc={stringNGrams:ob,stringSplit:ub,stringToHashBucketFast:cb,staticRegexReplace:hb};const mb=new Map,db=new Map;class fb{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Ze{constructor(){this.classNameMap={}}static getMap(){return Ze.instance==null&&(Ze.instance=new Ze),Ze.instance}static register(e){Ze.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function gb(n,e,t){g(n.className!=null,()=>"Class being registered does not have the static className property defined."),g(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),g(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return Ze.register(n),mb.set(s,n),db.set(n,s),n}class Ye extends fb{minimize(e,t=!1,r){const{value:s,grads:a}=this.computeGradients(e,r);if(r!=null){const o=r.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return se(a),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return bl(e,t)}dispose(){this.iterations_!=null&&se(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:B(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ye,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class Lc extends Ye{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=w.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=w.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:z(()=>pe(a).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:z(()=>pe(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;z(()=>{const p=A($(u,this.rho),$(ge(i),1-this.rho)),h=$(U(Ee(A(l,this.epsilon)),Ee(A(u,this.epsilon))),i),m=A($(l,this.rho),$(ge(h),1-this.rho));u.assign(p),l.assign(m);const f=A($(h,-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(se(this.accumulatedGrads.map(e=>e.variable)),se(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class zc extends Ye{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=w.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:z(()=>Et(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=this.accumulatedGrads[s].variable;z(()=>{const u=A(i,ge(o));i.assign(u);const l=A($(U(o,Ee(A(u,w.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&se(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class Vc extends Ye{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],z(()=>{this.accBeta1=B(t).variable(),this.accBeta2=B(r).variable()}),s==null&&(this.epsilon=w.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);z(()=>{const r=F(1,this.accBeta1),s=F(1,this.accBeta2);t.forEach((a,o)=>{const i=w.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:z(()=>pe(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:z(()=>pe(i).variable(u))});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const p=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,m=A($(p,this.beta1),$(l,1-this.beta1)),f=A($(h,this.beta2),$(ge(l),1-this.beta2)),b=U(m,r),k=U(f,s);p.assign(m),h.assign(f);const N=A($(U(b,A(Ee(k),this.epsilon)),-this.learningRate),i);i.assign(N)}),this.accBeta1.assign($(this.accBeta1,this.beta1)),this.accBeta2.assign($(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&se(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&se(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),z(()=>{this.accBeta1.assign(Nt(this.beta1,this.iterations_+1)),this.accBeta2.assign(Nt(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class jc extends Ye{static get className(){return"Adamax"}constructor(e,t,r,s=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],z(()=>{this.iteration=B(0).variable(),this.accBeta1=B(t).variable()}),s==null&&(this.epsilon=w.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);z(()=>{const r=F(1,this.accBeta1),s=U(-this.learningRate,A($(this.iteration,this.decay),1));t.forEach((a,o)=>{const i=w.registeredVariables[a],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:pe(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:pe(i).variable(u)});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const p=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,m=A($(p,this.beta1),$(l,1-this.beta1)),f=$(h,this.beta2),b=ce(l),k=Jr(f,b);p.assign(m),h.assign(k);const N=A($(U(s,r),U(m,A(k,this.epsilon))),i);i.assign(N)}),this.iteration.assign(A(this.iteration,1)),this.accBeta1.assign($(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&se(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&se(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class ws extends Ye{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const o=w.registeredVariables[r];z(()=>{const i=A($(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ne(B(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class qc extends ws{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=B(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=w.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:z(()=>pe(a).variable(!1))});const o=this.accumulations[s].variable,i=Array.isArray(e)?e[s].tensor:e[r];i!=null&&z(()=>{let u;const l=A($(this.m,o),i);this.useNesterov?u=A($(this.c,A(i,$(l,this.m))),a):u=A($(this.c,l),a),o.assign(l),a.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&se(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Uc extends Ye{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=w.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const a=w.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:z(()=>pe(a).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:z(()=>pe(a).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:z(()=>pe(a).variable(o))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const u=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;z(()=>{const p=A($(u,this.decay),$(ge(i),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,m=A($(h,this.decay),$(i,1-this.decay)),f=U($(i,this.learningRate),Ee(F(p,A(ge(m),this.epsilon)))),b=A($(l,this.momentum),f);u.assign(p),h.assign(m),l.assign(b);const k=F(a,b);a.assign(k)}else{const h=A($(u,this.decay),$(ge(i),1-this.decay)),m=A($(l,this.momentum),U($(i,this.learningRate),Ee(A(h,this.epsilon))));u.assign(h),l.assign(m);const f=F(a,m);a.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&se(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&se(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&se(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const yb=[Lc,zc,Vc,jc,qc,Uc,ws];function bb(){for(const n of yb)gb(n)}const wb="model",Nb=".json",kb=".weights.bin";function qs(n){return new Promise(e=>setTimeout(e)).then(n)}class ut{constructor(e){if(!R().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ut.URL_SCHEME)&&(e=e.slice(ut.URL_SCHEME.length)),(e==null||e.length===0)&&(e=wb),this.modelJsonFileName=e+Nb,this.weightDataFileName=e+kb}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Te.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=mu(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await qs(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=r,await qs(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ut(e)}}}}ut.URL_SCHEME="downloads://";class Sb{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=Dr(a,l=>this.loadWeights(l));e(u)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(a).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,s)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;r(i)},a.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(a=>Ds(a.name)),s={};for(const a of e)a.paths.forEach(o=>{const i=Ds(o);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Tb=n=>R().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ut.URL_SCHEME)?vb(n.slice(ut.URL_SCHEME.length)):null;K.registerSaveRouter(Tb);function vb(n="model"){return new ut(n)}function $b(n){return new Sb(n)}function Us(n,e,t,r){o(n),t=t??0,r=r??1,i(t,r);let s=0;const a=u=>(u.then(l=>{const p=t+ ++s/n.length*(r-t);return e(p),l}),u);function o(u){g(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){g(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),g(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),g(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(a))}async function Wc(n,e){e==null&&(e={});const t=e.fetchFunc==null?R().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),i=(e.onProgress==null?await Promise.all(r):await Us(r,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(i):await Us(i,e.onProgress,.5,1)}function Eb(n,e){var t;const r=e.fetchFunc==null?R().platform.fetch:e.fetchFunc;let s=0,a;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var i;s<n.length;){a||(a=(await r(n[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await a.read();if(u){s++,a=void 0,(i=e.onProgress)===null||i===void 0||i.call(e,s/n.length);continue}o.enqueue(l);return}o.close()}})}async function _b(n,e="",t,r){return Kc(o=>Wc(o,{requestInit:r}))(n,e,t)}function Kc(n){return async(e,t="",r)=>{const s=e.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((f,b)=>{let k=0;f.weights.forEach(N=>{const S="quantization"in N?N.quantization.dtype:N.dtype,x=at[S]*Y(N.shape),I=()=>{s[b]=!0,a[b]==null&&(a[b]=[]),a[b].push({manifestEntry:N,groupOffset:k,sizeBytes:x})};r!=null?r.forEach((v,E)=>{v===N.name&&(I(),o[E]=!0)}):I(),i.push(N.name),k+=x})}),!o.every(f=>f)){const f=r.filter((b,k)=>!o[k]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=s.reduce((f,b,k)=>(b&&f.push(k),f),[]),l=[];u.forEach(f=>{e[f].paths.forEach(b=>{const k=t+(t.endsWith("/")?"":"/")+b;l.push(k)})});const p=await n(l),h={};let m=0;return u.forEach(f=>{const b=e[f].paths.length,k=new Te(p.slice(m,m+b));a[f].forEach(S=>{const x=k.slice(S.groupOffset,S.groupOffset+S.sizeBytes),I=cu(x,[S.manifestEntry]);for(const v in I)h[v]=I[v]}),m+=b}),h}}const xb="application/octet-stream",Ib="application/json";class Ns{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(g(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=R().platform.fetch,g(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&g(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=mu(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:Ib}),"model.json"),e.weightData!=null){const o=Te.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:xb}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Ut(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Dr(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),r=rr(e.weightsManifest),s=()=>Eb(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=Ab(t),a=this.weightPathPrefix||r,o=[],i=[];for(const u of e)for(const l of u.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):o.push(a+l+s);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(e){const t=await this.getWeightUrls(e),r=rr(e),s=await Wc(t,this.loadOptions);return[r,s]}}Ns.URL_SCHEME_REGEX=/^https?:\/\//;function Ab(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function ur(n){return n.match(Ns.URL_SCHEME_REGEX)!=null}const Gc=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>ur(r)):t=ur(n),t)return ks(n,e)}return null};K.registerSaveRouter(Gc);K.registerLoadRouter(Gc);function ks(n,e){return new Ns(n,e)}function Db(n,e){return ks(n,e)}class jn{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Hc{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Ob{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Cb(n,e,t,r){const s=arguments;return new Ob(Mc(...s))}function Mc(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new jn(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jn({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new jn({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function Fb(n){return new Hc(n)}function Rb(n){return new Hc(n)}const Ss=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Te,browserFiles:$b,browserHTTPRequest:Db,concatenateArrayBuffers:qp,copyModel:ch,decodeWeights:cu,decodeWeightsStream:hu,encodeWeights:Pp,fromMemory:Cb,fromMemorySync:Mc,getLoadHandlers:Yp,getModelArtifactsForJSON:Dr,getModelArtifactsForJSONSync:du,getModelArtifactsInfoForJSON:Ut,getSaveHandlers:Xp,getWeightSpecs:rr,http:ks,isHTTPScheme:ur,listModels:uh,loadWeights:_b,moveModel:ph,registerLoadRouter:Mp,registerSaveRouter:Hp,removeModel:lh,weightsLoaderFactory:Kc,withSaveHandler:Fb,withSaveHandlerSync:Rb},Symbol.toStringTag,{value:"Module"}));let Je;function Pb(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)a=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(hn(Gn,w.backendName)!=null){const b={pixels:n},k={numChannels:e};return w.runKernel(Gn,b,k)}const[l,p]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,l,p).data;else if(r||t)h=n.data;else if(a||s||i){if(Je==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Je=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Je=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Je.canvas.width=l,Je.canvas.height=p,Je.drawImage(n,0,0,l,p),h=Je.getImageData(0,0,l,p).data}let m;if(e===4)m=new Int32Array(h);else{const b=l*p;m=new Int32Array(b*e);for(let k=0;k<b;k++)for(let N=0;N<e;++N)m[k*e+N]=h[k*4+N]}return cs(m,[p,l,e],"int32")}const Bb=y({fromPixels_:Pb});bb();const Lb=Object.freeze(Object.defineProperty({__proto__:null,Abs:oa,Acos:ia,Acosh:ua,AdadeltaOptimizer:Lc,AdagradOptimizer:zc,AdamOptimizer:Vc,AdamaxOptimizer:jc,Add:$r,AddN:la,All:ca,Any:pa,ArgMax:ha,ArgMin:ma,Asin:da,Asinh:fa,Atan:ga,Atan2:ba,Atanh:ya,AvgPool:wa,AvgPool3D:Na,BatchMatMul:ka,BatchToSpaceND:Sa,Bincount:Ta,BitwiseAnd:va,BroadcastArgs:$a,Cast:Er,Ceil:Ea,ClipByValue:_a,Complex:xa,ComplexAbs:Ia,Concat:Aa,Conv2D:Da,Conv2DBackpropFilter:Oa,Conv2DBackpropInput:Ca,Conv3D:Fa,Conv3DBackpropInputV2:Ra,Cos:Pa,Cosh:Ba,CropAndResize:Va,Cumprod:La,Cumsum:za,DenseBincount:ja,DepthToSpace:qa,DepthwiseConv2dNative:Ua,DepthwiseConv2dNativeBackpropFilter:Wa,DepthwiseConv2dNativeBackpropInput:Ka,Diag:Ga,Dilation2D:Ha,get ENV(){return Tr},Einsum:Xa,Elu:Ya,Environment:sa,Equal:Qa,Erf:Ja,Exp:Za,ExpandDims:eo,Expm1:to,FFT:no,Fill:ro,FlipLeftRight:so,Floor:ao,FloorDiv:oo,FromPixels:Gn,FusedBatchNorm:io,FusedConv2D:Mn,FusedDepthwiseConv2D:Xn,GatherNd:lo,GatherV2:uo,Greater:co,GreaterEqual:po,IFFT:ho,Identity:_r,Imag:mo,IsFinite:fo,IsInf:go,IsNan:yo,KernelBackend:ea,LRN:_o,LeakyRelu:bo,Less:wo,LessEqual:No,LinSpace:ko,Log:So,Log1p:To,LogicalAnd:vo,LogicalNot:$o,LogicalOr:Eo,Max:xo,MaxPool:Ao,MaxPool3D:Do,MaxPoolWithArgmax:Oo,Maximum:Io,Mean:Co,Min:Fo,Minimum:Ro,MirrorPad:Po,Mod:Bo,MomentumOptimizer:qc,Multinomial:Lo,Multiply:zo,Neg:Vo,NonMaxSuppressionV3:qo,NonMaxSuppressionV4:Uo,NonMaxSuppressionV5:Wo,NotEqual:jo,OP_SCOPE_SUFFIX:Ir,OneHot:Go,OnesLike:Ko,Optimizer:Ye,Pack:Ho,PadV2:Mo,Pow:Xo,Prelu:Yo,Prod:Jo,RMSPropOptimizer:Uc,RaggedGather:Qo,RaggedRange:Zo,RaggedTensorToTensor:ei,Range:ti,get Rank(){return Qn},Real:ni,RealDiv:Ma,Reciprocal:ri,get Reduction(){return re},Relu:si,Relu6:ui,Reshape:ai,ResizeBilinear:ii,ResizeNearestNeighbor:oi,Reverse:li,RotateWithOffset:Xi,Round:ci,Rsqrt:pi,SGDOptimizer:ws,ScatterNd:hi,SearchSorted:di,Select:fi,Selu:gi,Sigmoid:ki,Sign:Ni,Sin:bi,Sinh:wi,Slice:yi,Softmax:_i,Softplus:Si,SpaceToBatchND:$i,SparseFillEmptyRows:xi,SparseReshape:Ii,SparseSegmentMean:Ai,SparseSegmentSum:Di,SparseToDense:Oi,SplitV:Ei,Sqrt:Ti,SquaredDifference:Ci,StaticRegexReplace:Fi,Step:Mi,StridedSlice:Ri,StringNGrams:Pi,StringSplit:Bi,StringToHashBucketFast:Li,Sub:zi,Sum:vi,Tan:Vi,Tanh:ji,Tensor:Q,TensorBuffer:dn,TensorScatterUpdate:mi,Tile:xr,TopK:qi,Transform:Ui,Transpose:en,Unique:Wi,Unpack:Ki,UnsortedSegmentSum:Gi,Variable:Bt,ZerosLike:Hi,_FusedMatMul:Hn,abs:ce,acos:Su,acosh:Tu,add:A,addN:vu,all:$u,any:Eu,argMax:_u,argMin:xu,asin:Iu,asinh:Au,atan:Du,atan2:Ou,atanh:Cu,avgPool:Rr,avgPool3d:Fu,backend:lu,basicLSTMCell:Ru,batchNorm:Wt,batchNorm2d:Pu,batchNorm3d:Bu,batchNorm4d:Lu,batchToSpaceND:Pr,bincount:Br,bitwiseAnd:zu,booleanMaskAsync:Sc,broadcastArgs:Vu,broadcastTo:Ft,buffer:$e,cast:G,ceil:ju,clipByValue:qu,clone:Fe,complex:Be,concat:te,concat1d:Uu,concat2d:Wu,concat3d:Ku,concat4d:Gu,conv1d:Hu,conv2d:Kt,conv2dTranspose:Xu,conv3d:Yu,conv3dTranspose:Ju,cos:Qu,cosh:Zu,cosineWindow:Rn,cumprod:el,cumsum:tl,customGrad:_e,denseBincount:nl,depthToSpace:rl,depthwiseConv2d:xn,diag:sl,dilation2d:al,dispose:se,div:U,divNoNan:ol,dot:il,dropout:_c,einsum:Qe,elu:zr,enclosingPowerOfTwo:hs,ensureShape:ul,env:R,equal:Lr,erf:ll,euclideanNorm:pl,exp:Ue,expandDims:Ae,expm1:hl,eye:Vr,fft:Cn,fill:Et,floor:jr,floorDiv:Cr,fused:Ic,gather:qr,gatherND:Ec,getBackend:uu,getGradient:Yn,getKernel:hn,getKernelsForBackend:Jn,greater:Ht,greaterEqual:Ur,ifft:qt,imag:Mt,image:bs,inTopKAsync:xc,io:Ss,irfft:is,isFinite:ml,isInf:dl,isNaN:fl,keep:Ne,leakyRelu:Wr,less:Nn,lessEqual:An,linalg:Fc,linspace:gl,localResponseNormalization:yl,log:kt,log1p:Kr,logSigmoid:wl,logSoftmax:Nl,logSumExp:Hr,logicalAnd:zt,logicalNot:Mr,logicalOr:Xr,logicalXor:kl,losses:Rc,lowerBound:Sl,matMul:V,max:rt,maxPool:Yr,maxPool3d:Tl,maxPoolWithArgmax:vl,maximum:Jr,mean:Vt,meshgrid:$l,min:wn,minimum:jt,mirrorPad:El,mod:_l,moments:xl,movingAverage:Tc,mul:$,multiRNNCell:Il,multinomial:Al,neg:Se,norm:Gt,notEqual:Qr,oneHot:Dl,ones:je,onesLike:Ol,op:y,outerProduct:Cl,pad:_t,pad1d:Fl,pad2d:Rl,pad3d:Pl,pad4d:Bl,pool:Ll,pow:Nt,prelu:es,print:Or,prod:zl,raggedGather:Vl,raggedRange:jl,raggedTensorToTensor:ql,rand:Ul,randomGamma:Wl,randomNormal:rs,randomStandardNormal:Kl,randomUniform:On,randomUniformInt:Gl,range:St,real:Tt,reciprocal:Hl,relu:Xt,relu6:ss,reshape:T,reverse:Ke,reverse1d:Ml,reverse2d:Xl,reverse3d:Yl,reverse4d:Jl,rfft:Fn,round:as,rsqrt:Ql,scalar:B,scatterND:vc,searchSorted:Dn,selu:Zl,separableConv2d:ec,setdiff1dAsync:tc,sigmoid:nt,sign:nc,signal:Cc,sin:rc,sinh:sc,slice:j,slice1d:ac,slice2d:oc,slice3d:ic,slice4d:uc,softmax:os,softplus:Gr,spaceToBatchND:Zr,sparse:Pc,sparseToDense:$c,spectral:Oc,split:vt,sqrt:Ee,square:ge,squaredDifference:us,squeeze:Yt,stack:xe,step:ls,stridedSlice:lc,string:Bc,sub:F,sum:q,tan:cc,tanh:bn,tensor:ke,tensor1d:he,tensor2d:yt,tensor3d:cs,tensor4d:pc,tensor5d:hc,tensor6d:mc,tensorScatterUpdate:fc,tidy:z,tile:gt,topk:gc,transpose:kn,truncatedNormal:yc,unique:bc,unsortedSegmentSum:wc,unstack:Xe,upcastType:tu,upperBound:Nc,variable:kc,variableGrads:bl,where:Re,whereAsync:ps,zeros:We,zerosLike:pe},Symbol.toStringTag,{value:"Module"}));const zb=R();zb.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var ue;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ue||(ue={}));var Ws;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Ws||(Ws={}));const Vb={};function Xc(n){return Vb[n]}function c(n,e,t,r,s){const a=e.inputParams[n];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd,l=i<0?e.inputNames.length+i:i;if(a.type==="tensor")return Z(e.inputNames[l],t,r,s);if(a.type==="tensors"){const m=e.inputs.slice(i,u);return e.inputNames.slice(i,u).filter((b,k)=>{var N;return((N=m[k])===null||N===void 0?void 0:N.op)!=="NoOp"}).map(b=>Z(b,t,r,s))}const p=Z(e.inputNames[l],t,r,s),h=p.dataSync();return a.type==="number"?h[0]:Kn(p.shape,h)}const o=e.attrParams[n];return o&&o.value}function Z(n,e,t,r){const[s,a]=le(n,t);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const o=t.currentContextIds.find(i=>!!e[Sn(s,i)]);return o!==void 0?e[Sn(s,o)][a]:void 0}function Ks(n,e,t){return e[Sn(n,t.currentContextId)]}function De(n,e){const[t,r,s]=le(n,e);return[Sn(t,e&&e.currentContextId),r,s]}function Sn(n,e){return e?`${n}-${e}`:n}function le(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const a=e.parseNodeNameCache.get(n);if(a!=null)return a}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const a=r[0],o=r.length===3?r[1]:void 0,i=Number(r[r.length-1]);s=[a,i,o]}return t&&e.parseNodeNameCache.set(n,s),s}function pn(n,e,t){let r=c("pad",n,e,t);if(r==="explicit"){r=c("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Oe(n){return n.kept?n:Fe(n)}const jb=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],qb=Object.freeze(Object.defineProperty({__proto__:null,json:jb},Symbol.toStringTag,{value:"Module"}));const Ub=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Wb=Object.freeze(Object.defineProperty({__proto__:null,json:Ub},Symbol.toStringTag,{value:"Module"}));const Kb=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Gb=Object.freeze(Object.defineProperty({__proto__:null,json:Kb},Symbol.toStringTag,{value:"Module"}));const Hb=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Mb=Object.freeze(Object.defineProperty({__proto__:null,json:Hb},Symbol.toStringTag,{value:"Module"}));const Xb=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Yb=Object.freeze(Object.defineProperty({__proto__:null,json:Xb},Symbol.toStringTag,{value:"Module"}));const Jb=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Qb=Object.freeze(Object.defineProperty({__proto__:null,json:Jb},Symbol.toStringTag,{value:"Module"}));const Zb=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],ew=Object.freeze(Object.defineProperty({__proto__:null,json:Zb},Symbol.toStringTag,{value:"Module"}));const tw=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],nw=Object.freeze(Object.defineProperty({__proto__:null,json:tw},Symbol.toStringTag,{value:"Module"}));const rw=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],sw=Object.freeze(Object.defineProperty({__proto__:null,json:rw},Symbol.toStringTag,{value:"Module"}));const aw=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],ow=Object.freeze(Object.defineProperty({__proto__:null,json:aw},Symbol.toStringTag,{value:"Module"}));const iw=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],uw=Object.freeze(Object.defineProperty({__proto__:null,json:iw},Symbol.toStringTag,{value:"Module"}));const lw=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],cw=Object.freeze(Object.defineProperty({__proto__:null,json:lw},Symbol.toStringTag,{value:"Module"}));const pw=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],hw=Object.freeze(Object.defineProperty({__proto__:null,json:pw},Symbol.toStringTag,{value:"Module"}));const mw=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],dw=Object.freeze(Object.defineProperty({__proto__:null,json:mw},Symbol.toStringTag,{value:"Module"}));const fw=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],gw=Object.freeze(Object.defineProperty({__proto__:null,json:fw},Symbol.toStringTag,{value:"Module"}));const yw=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],bw=Object.freeze(Object.defineProperty({__proto__:null,json:yw},Symbol.toStringTag,{value:"Module"}));const ww=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Nw=Object.freeze(Object.defineProperty({__proto__:null,json:ww},Symbol.toStringTag,{value:"Module"}));const kw=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Sw=Object.freeze(Object.defineProperty({__proto__:null,json:kw},Symbol.toStringTag,{value:"Module"}));const Tw=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],vw=Object.freeze(Object.defineProperty({__proto__:null,json:Tw},Symbol.toStringTag,{value:"Module"}));class Gs{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[qb,Wb,Gb,Mb,Yb,Qb,ew,nw,sw,ow,uw,cw,hw,dw,gw,bw,Nw,Sw,vw],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],a=[],o=[],i=r.reduce((k,N)=>(k[N.name]=this.mapNode(N),N.op.startsWith("Placeholder")?s.push(k[N.name]):N.op==="Const"?a.push(k[N.name]):(N.input==null||N.input.length===0)&&o.push(k[N.name]),k),{});let u=[];const l=[];let p={},h={};t!=null&&(p=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const m=Object.keys(i);m.forEach(k=>{const N=i[k];N.inputNames.forEach((S,x)=>{const[I,,v]=De(S),E=i[I];if(E.outputs!=null){const _=E.outputs.indexOf(v);if(_!==-1){const D=`${I}:${_}`;N.inputNames[x]=D}}N.inputs.push(E),E.children.push(N)})}),Object.keys(h).length===0?m.forEach(k=>{const N=i[k];N.children.length===0&&l.push(N)}):Object.keys(h).forEach(k=>{const[N]=De(k),S=i[N];S!=null&&(S.signatureKey=h[k],l.push(S))}),Object.keys(p).length>0?Object.keys(p).forEach(k=>{const[N]=De(k),S=i[N];S&&(S.signatureKey=p[k],u.push(S))}):u=s;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((k,N)=>(k[N.signature.name]=this.mapFunction(N),k),{}));const b={nodes:i,inputs:u,outputs:l,weights:a,placeholders:s,signature:t,functions:f};return o.length>0&&(b.initNodes=o),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Xc(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,a)=>{const o=a.type;let i;switch(a.type){case"string":i=lr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=lr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=gr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=gr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=pr(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=pr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=fr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=fr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=cr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=cr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=br(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=br(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=dr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=dr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=yr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=yr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=hr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=hr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=mr(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=mr(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=Hs(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Hs(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:i,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let a={};t!=null&&(a=t.reduce((h,m)=>(h[m.name]=this.mapNode(m),m.op==="Const"&&s.push(h[m.name]),h),{}));const o=[],i=[];e.signature.inputArg.forEach(h=>{const[m]=De(h.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ts(h.type),type:"dtype"}},children:[]};f.signatureKey=h.name,o.push(f),a[m]=f}),Object.keys(a).forEach(h=>{const m=a[h];m.inputNames.forEach((f,b)=>{const[k,,N]=De(f),S=a[k];if(S.outputs!=null){const x=S.outputs.indexOf(N);if(x!==-1){const I=`${k}:${x}`;m.inputNames[b]=I}}m.inputs.push(S),S.children.push(m)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[m,f]=De(l[h.name]),b=a[m];b!=null&&(b.defaultOutput=f,i.push(b))});const p=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:s,placeholders:r,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function $w(n){const e=R().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Yc(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):$w(n);return e?t:t.toLowerCase()}function lr(n,e,t,r=!1){const s=n[e];return s!=null?Yc(s.s,r):t}function cr(n,e,t){const r=n[e];return r?r.b:t}function pr(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function Ts(n){switch(typeof n=="string"&&(n=ue[n]),n){case ue.DT_FLOAT:case ue.DT_HALF:return"float32";case ue.DT_INT32:case ue.DT_INT64:case ue.DT_INT8:case ue.DT_UINT8:return"int32";case ue.DT_BOOL:return"bool";case ue.DT_DOUBLE:return"float32";case ue.DT_STRING:return"string";case ue.DT_COMPLEX64:case ue.DT_COMPLEX128:return"complex64";default:return null}}function Hs(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function hr(n,e,t){const r=n[e];return r&&r.type?Ts(r.type):t}function mr(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Ts(s)):t}function Jc(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function dr(n,e,t){const r=n[e];return r&&r.shape?Jc(r.shape):t}function fr(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function gr(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(a=>Yc(a,r)):t}function yr(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Jc(s)):t}function br(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}class Ew{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return Z(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Z(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return pr(this.node.rawAttrs,e,t);if(r.s!=null)return lr(this.node.rawAttrs,e,t);if(r.b!=null)return cr(this.node.rawAttrs,e,t);if(r.shape!=null)return dr(this.node.rawAttrs,e,t);if(r.type!=null)return hr(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return fr(this.node.rawAttrs,e,t);if(r.list.s!=null)return gr(this.node.rawAttrs,e,t);if(r.list.shape!=null)return yr(this.node.rawAttrs,e,t);if(r.list.b!=null)return br(this.node.rawAttrs,e,t);if(r.list.type!=null)return mr(this.node.rawAttrs,e,t)}return t}}const ee=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Ir,abs:ce,acos:Su,acosh:Tu,add:A,addN:vu,all:$u,any:Eu,argMax:_u,argMin:xu,asin:Iu,asinh:Au,atan:Du,atan2:Ou,atanh:Cu,avgPool:Rr,avgPool3d:Fu,basicLSTMCell:Ru,batchNorm:Wt,batchNorm2d:Pu,batchNorm3d:Bu,batchNorm4d:Lu,batchToSpaceND:Pr,bincount:Br,bitwiseAnd:zu,booleanMaskAsync:Sc,broadcastArgs:Vu,broadcastTo:Ft,buffer:$e,cast:G,ceil:ju,clipByValue:qu,clone:Fe,complex:Be,concat:te,concat1d:Uu,concat2d:Wu,concat3d:Ku,concat4d:Gu,conv1d:Hu,conv2d:Kt,conv2dTranspose:Xu,conv3d:Yu,conv3dTranspose:Ju,cos:Qu,cosh:Zu,cosineWindow:Rn,cumprod:el,cumsum:tl,denseBincount:nl,depthToSpace:rl,depthwiseConv2d:xn,diag:sl,dilation2d:al,div:U,divNoNan:ol,dot:il,dropout:_c,einsum:Qe,elu:zr,enclosingPowerOfTwo:hs,ensureShape:ul,equal:Lr,erf:ll,euclideanNorm:pl,exp:Ue,expandDims:Ae,expm1:hl,eye:Vr,fft:Cn,fill:Et,floor:jr,floorDiv:Cr,fused:Ic,gather:qr,gatherND:Ec,greater:Ht,greaterEqual:Ur,ifft:qt,imag:Mt,image:bs,inTopKAsync:xc,irfft:is,isFinite:ml,isInf:dl,isNaN:fl,leakyRelu:Wr,less:Nn,lessEqual:An,linalg:Fc,linspace:gl,localResponseNormalization:yl,log:kt,log1p:Kr,logSigmoid:wl,logSoftmax:Nl,logSumExp:Hr,logicalAnd:zt,logicalNot:Mr,logicalOr:Xr,logicalXor:kl,losses:Rc,lowerBound:Sl,matMul:V,max:rt,maxPool:Yr,maxPool3d:Tl,maxPoolWithArgmax:vl,maximum:Jr,mean:Vt,meshgrid:$l,min:wn,minimum:jt,mirrorPad:El,mod:_l,moments:xl,movingAverage:Tc,mul:$,multiRNNCell:Il,multinomial:Al,neg:Se,norm:Gt,notEqual:Qr,oneHot:Dl,ones:je,onesLike:Ol,op:y,outerProduct:Cl,pad:_t,pad1d:Fl,pad2d:Rl,pad3d:Pl,pad4d:Bl,pool:Ll,pow:Nt,prelu:es,print:Or,prod:zl,raggedGather:Vl,raggedRange:jl,raggedTensorToTensor:ql,rand:Ul,randomGamma:Wl,randomNormal:rs,randomStandardNormal:Kl,randomUniform:On,randomUniformInt:Gl,range:St,real:Tt,reciprocal:Hl,relu:Xt,relu6:ss,reshape:T,reverse:Ke,reverse1d:Ml,reverse2d:Xl,reverse3d:Yl,reverse4d:Jl,rfft:Fn,round:as,rsqrt:Ql,scalar:B,scatterND:vc,searchSorted:Dn,selu:Zl,separableConv2d:ec,setdiff1dAsync:tc,sigmoid:nt,sign:nc,signal:Cc,sin:rc,sinh:sc,slice:j,slice1d:ac,slice2d:oc,slice3d:ic,slice4d:uc,softmax:os,softplus:Gr,spaceToBatchND:Zr,sparse:Pc,sparseToDense:$c,spectral:Oc,split:vt,sqrt:Ee,square:ge,squaredDifference:us,squeeze:Yt,stack:xe,step:ls,stridedSlice:lc,string:Bc,sub:F,sum:q,tan:cc,tanh:bn,tensor:ke,tensor1d:he,tensor2d:yt,tensor3d:cs,tensor4d:pc,tensor5d:hc,tensor6d:mc,tensorScatterUpdate:fc,tile:gt,topk:gc,transpose:kn,truncatedNormal:yc,unique:bc,unsortedSegmentSum:wc,unstack:Xe,upperBound:Nc,variable:kc,where:Re,whereAsync:ps,zeros:We,zerosLike:pe},Symbol.toStringTag,{value:"Module"}));const _w=(n,e,t,r=ee)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(c("a",n,e,t),c("b",n,e,t))];case"AddN":return[r.addN(c("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(c("a",n,e,t),c("b",n,e,t))];case"Mul":return[r.mul(c("a",n,e,t),c("b",n,e,t))];case"RealDiv":case"Div":return[r.div(c("a",n,e,t),c("b",n,e,t))];case"DivNoNan":return[r.divNoNan(c("a",n,e,t),c("b",n,e,t))];case"FloorDiv":return[r.floorDiv(c("a",n,e,t),c("b",n,e,t))];case"Sub":return[r.sub(c("a",n,e,t),c("b",n,e,t))];case"Minimum":return[r.minimum(c("a",n,e,t),c("b",n,e,t))];case"Maximum":return[r.maximum(c("a",n,e,t),c("b",n,e,t))];case"Pow":return[r.pow(c("a",n,e,t),c("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(c("a",n,e,t),c("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const xw=(n,e,t,r=ee)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(c("x",n,e,t))];case"Acos":return[r.acos(c("x",n,e,t))];case"Acosh":return[r.acosh(c("x",n,e,t))];case"Asin":return[r.asin(c("x",n,e,t))];case"Asinh":return[r.asinh(c("x",n,e,t))];case"Atan":return[r.atan(c("x",n,e,t))];case"Atan2":return[r.atan2(c("x",n,e,t),c("y",n,e,t))];case"Atanh":return[r.atanh(c("x",n,e,t))];case"Ceil":return[r.ceil(c("x",n,e,t))];case"Complex":return[r.complex(c("real",n,e,t),c("imag",n,e,t))];case"Cos":return[r.cos(c("x",n,e,t))];case"Cosh":return[r.cosh(c("x",n,e,t))];case"Elu":return[r.elu(c("x",n,e,t))];case"Erf":return[r.erf(c("x",n,e,t))];case"Exp":return[r.exp(c("x",n,e,t))];case"Expm1":return[r.expm1(c("x",n,e,t))];case"Floor":return[r.floor(c("x",n,e,t))];case"Log":return[r.log(c("x",n,e,t))];case"Log1p":return[r.log1p(c("x",n,e,t))];case"Imag":return[r.imag(c("x",n,e,t))];case"Neg":return[r.neg(c("x",n,e,t))];case"Reciprocal":return[r.reciprocal(c("x",n,e,t))];case"Real":return[r.real(c("x",n,e,t))];case"Relu":return[r.relu(c("x",n,e,t))];case"Round":return[r.round(c("x",n,e,t))];case"Selu":return[r.selu(c("x",n,e,t))];case"Sigmoid":return[r.sigmoid(c("x",n,e,t))];case"Sin":return[r.sin(c("x",n,e,t))];case"Sign":return[r.sign(c("x",n,e,t))];case"Sinh":return[r.sinh(c("x",n,e,t))];case"Softplus":return[r.softplus(c("x",n,e,t))];case"Sqrt":return[r.sqrt(c("x",n,e,t))];case"Square":return[r.square(c("x",n,e,t))];case"Tanh":return[r.tanh(c("x",n,e,t))];case"Tan":return[r.tan(c("x",n,e,t))];case"ClipByValue":return[r.clipByValue(c("x",n,e,t),c("clipValueMin",n,e,t),c("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(c("x",n,e,t))];case"Rsqrt":return[r.rsqrt(Z(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(c("x",n,e,t),c("alpha",n,e,t))];case"Prelu":return[r.prelu(c("x",n,e,t),c("alpha",n,e,t))];case"IsNan":return[r.isNaN(Z(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(Z(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(Z(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function fe(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){g(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],a=e[r];g(s<0||a<0||s===a,()=>t+` Shapes ${n} and ${e} must match`)}}}function Ms(n){return!(typeof n=="number"||n.some(e=>e<0))}function Dt(n,e,t){let r=wr(n,t);const s=!Ms(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=wr(a.shape,r)}),!Ms(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function wr(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:a}return t}class Iw{constructor(e,t,r,s,a,o,i){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=B(0),Ne(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),fe(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Ne(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return ke([],[0].concat(this.elementShape));const r=this.readMany(e);return fe(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),xe(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ke([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return fe(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),te(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Xe(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:t.size/r,o=[];z(()=>{t=T(t,[1,r,a]);for(let u=0;u<e.length;++u){const p=[0,u===0?0:s[u-1],0],h=[1,e[u],a];o[u]=T(j(t,p,h),this.elementShape)}return o});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,o)}}class lt{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e?.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);fe(t,a.shape,"TensorList shape mismatch: "),Ne(a)}),this.idTensor=B(0),this.maxNumElements=s,Ne(this.idTensor)}copy(){return new lt([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);fe(e,this.elementShape,"TensorList shape mismatch: ");const s=Dt(this.elementShape,this.tensors,e);return z(()=>{const a=this.tensors.map(o=>T(o,s));return xe(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Dt(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,fe(s.shape,e,"TensorList shape mismatch: "),T(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(fe(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ne(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new lt([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);fe(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Dt(this.elementShape,this.tensors,t);return T(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);fe(this.elementShape,t.shape,"TensorList shape mismatch: "),Ne(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);fe(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Dt(this.elementShape,this.tensors,r);return e.length===0?ke([],[0].concat(s)):z(()=>{const a=e.map(o=>T(this.tensors[o],s));return xe(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);fe(this.elementShape,t,"TensorList shape mismatch: ");const r=Dt(this.elementShape,this.tensors,t);return this.size()===0?ke([],[0].concat(r)):z(()=>{const s=this.tensors.map(a=>T(a,r));return te(s,0)})}}function Aw(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);fe(s,e,"TensorList shape mismatch: ");const a=Xe(n);return new lt(a,e,r)}function Dw(n,e,t,r){return new lt([],n,e,r)}function Ow(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new lt([],t,n.dtype,r),o=Xe(n,0);return e.forEach((i,u)=>{a.setItem(i,o[u])}),a}function Cw(n,e,t){let r=0;const s=e.map(p=>(r+=p,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),o=wr(a,t),i=r===0?0:n.size/r,u=z(()=>{const p=[];n=T(n,[1,r,i]);for(let h=0;h<e.length;++h){const f=[0,h===0?0:s[h-1],0],b=[1,e[h],i];p[h]=T(j(n,f,b),o)}return n.dispose(),p}),l=new lt([],t,n.dtype,e.length);for(let p=0;p<u.length;p++)l.setItem(p,u[p]);return l}const Fw=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=c("thenBranch",n,e,t),s=c("elseBranch",n,e,t),a=c("cond",n,e,t),o=c("args",n,e,t);return(await a.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=c("body",n,e,t),s=c("cond",n,e,t),a=c("args",n,e,t),o=await t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),i=a.map(p=>p.id);let u=await o[0].data();o.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&p.dispose()});let l=a;for(;u[0];){const p=l;l=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const h=l.map(f=>f.id);p.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()});const m=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{const r=c("pred",n,e,t);return[Oe(r)]}case"Switch":{const r=c("pred",n,e,t);let s=c("data",n,e,t);return s.kept||(s=Oe(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>Z(s,e,t)!==void 0);if(r){const s=Z(r,e,t);return[Oe(s)]}return}case"Enter":{const r=c("frameName",n,e,t),s=c("tensor",n,e,t);return t.enterFrame(r),[Oe(s)]}case"Exit":{const r=c("tensor",n,e,t);return t.exitFrame(),[Oe(r)]}case"NextIteration":{const r=c("tensor",n,e,t);return t.nextIteration(),[Oe(r)]}case"TensorArrayV3":{const r=c("size",n,e,t),s=c("dtype",n,e,t),a=c("elementShape",n,e,t),o=c("dynamicSize",n,e,t),i=c("clearAfterRead",n,e,t),u=c("identicalElementShapes",n,e,t),l=c("name",n,e,t),p=new Iw(l,s,r,a,u,o,i);return t.addTensorArray(p),[p.idTensor,B(1)]}case"TensorArrayWriteV3":{const r=c("tensorArrayId",n,e,t),s=c("index",n,e,t),a=c("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const r=c("tensorArrayId",n,e,t),s=c("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=c("tensorArrayId",n,e,t),s=c("indices",n,e,t),a=c("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=c("tensorArrayId",n,e,t),s=c("indices",n,e,t),a=c("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const r=c("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),a=c("dtype",n,e,t);return[s.concat(a)]}case"TensorArraySplitV3":{const r=c("tensorArrayId",n,e,t),s=c("tensor",n,e,t),a=c("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const r=c("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[B(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=c("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=c("tensorListId",n,e,t),s=c("index",n,e,t),a=c("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const r=c("tensorListId",n,e,t),s=c("index",n,e,t),a=c("elementShape",n,e,t),o=c("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=c("indices",n,e,t),s=c("tensor",n,e,t),a=c("elementShape",n,e,t),o=c("numElements",n,e,t),i=Ow(s,r,a,o);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=c("elementShape",n,e,t),s=c("elementDType",n,e,t);let a;n.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=c(a,n,e,t),i=n.op==="TensorListReserve"?-1:o,u=Dw(r,s,o,i);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=c("tensorListId",n,e,t),s=c("indices",n,e,t),a=c("elementShape",n,e,t),o=c("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{const r=c("tensorListId",n,e,t),s=c("elementShape",n,e,t),a=c("elementDType",n,e,t),o=c("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{const r=c("tensor",n,e,t),s=c("elementShape",n,e,t),a=c("elementDType",n,e,t),o=Aw(r,s,a);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=c("tensorListId",n,e,t),s=t.getTensorList(r.id),a=c("dtype",n,e,t),o=c("elementShape",n,e,t);return[s.concat(a,o)]}case"TensorListPushBack":{const r=c("tensorListId",n,e,t),s=c("tensor",n,e,t),a=t.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=c("tensorListId",n,e,t),s=c("elementShape",n,e,t),a=c("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=c("tensor",n,e,t),s=c("elementShape",n,e,t),a=c("lengths",n,e,t),o=Cw(r,a,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=c("tensorListId",n,e,t),s=t.getTensorList(r.id);return[B(s.size(),"int32")]}case"TensorListResize":{const r=c("tensorListId",n,e,t),s=c("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Xs(n,e,t){const[r,s]=c("fusedOps",n,e,t),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=c("numArgs",n,e,t);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=c("strides",n,e,t),h=pn(n,e,t),m=c("dataFormat",n,e,t).toUpperCase(),f=c("dilations",n,e,t);let[b,k]=c("args",n,e,t);o&&(k=b,b=void 0);const N=c("leakyreluAlpha",n,e,t);return{stride:p,pad:h,dataFormat:m,dilations:f,biasArg:b,preluArg:k,activationFunc:s,leakyreluAlpha:N}}const Rw=(n,e,t,r=ee)=>{switch(n.op){case"Conv1D":{const s=c("stride",n,e,t),a=c("pad",n,e,t),o=c("dataFormat",n,e,t).toUpperCase(),i=c("dilation",n,e,t);return[r.conv1d(c("x",n,e,t),c("filter",n,e,t),s,a,o,i)]}case"Conv2D":{const s=c("strides",n,e,t),a=pn(n,e,t),o=c("dataFormat",n,e,t).toUpperCase(),i=c("dilations",n,e,t);return[r.conv2d(c("x",n,e,t),c("filter",n,e,t),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:h}=Xs(n,e,t);return[r.fused.conv2d({x:c("x",n,e,t),filter:c("filter",n,e,t),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:h}=Xs(n,e,t);return[r.fused.depthwiseConv2d({x:c("x",n,e,t),filter:c("filter",n,e,t),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=c("outputShape",n,e,t),a=c("strides",n,e,t),o=pn(n,e,t);return[r.conv2dTranspose(c("x",n,e,t),c("filter",n,e,t),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=c("strides",n,e,t),a=pn(n,e,t),o=c("dilations",n,e,t),i=c("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(c("input",n,e,t),c("filter",n,e,t),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("dataFormat",n,e,t).toUpperCase(),i=c("dilations",n,e,t);return[r.conv3d(c("x",n,e,t),c("filter",n,e,t),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("kernelSize",n,e,t);return[r.avgPool(c("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("kernelSize",n,e,t);return[r.maxPool(c("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("kernelSize",n,e,t),i=c("includeBatchInIndex",n,e,t),{result:u,indexes:l}=r.maxPoolWithArgmax(c("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a,i);return[u,l]}case"AvgPool3D":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("kernelSize",n,e,t);return[r.avgPool3d(c("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("kernelSize",n,e,t);return[r.maxPool3d(c("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=c("strides",n,e,t),a=c("pad",n,e,t),o=c("dilations",n,e,t),i=s[1],u=s[2],l=o[1],p=o[2];return[r.dilation2d(c("x",n,e,t),c("filter",n,e,t),[i,u],a,[l,p],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Pw=(n,e,t,r=ee)=>{switch(n.op){case"Fill":{const s=c("shape",n,e,t),a=c("dtype",n,e,t),o=c("value",n,e,t);return[r.fill(s,o,a)]}case"LinSpace":{const s=c("start",n,e,t),a=c("stop",n,e,t),o=c("num",n,e,t);return[r.linspace(s,a,o)]}case"Multinomial":{const s=c("logits",n,e,t),a=c("numSamples",n,e,t),o=c("seed",n,e,t);return[r.multinomial(s,a,o)]}case"OneHot":{const s=c("indices",n,e,t),a=c("depth",n,e,t),o=c("onValue",n,e,t),i=c("offValue",n,e,t),u=c("dtype",n,e,t);return[r.oneHot(s,a,o,i,u)]}case"Ones":return[r.ones(c("shape",n,e,t),c("dtype",n,e,t))];case"OnesLike":return[r.onesLike(c("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(c("shape",n,e,t),c("dtype",n,e,t),c("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(c("shape",n,e,t),c("minval",n,e,t),c("maxval",n,e,t),c("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(c("shape",n,e,t),c("minval",n,e,t),c("maxval",n,e,t),c("seed",n,e,t))];case"Range":{const s=c("start",n,e,t),a=c("stop",n,e,t),o=c("step",n,e,t);return[r.range(s,a,o,c("dtype",n,e,t))]}case"TruncatedNormal":{const s=c("shape",n,e,t),a=c("mean",n,e,t),o=c("stdDev",n,e,t),i=c("seed",n,e,t);return[r.truncatedNormal(s,a,o,c("dtype",n,e,t),i)]}case"Zeros":return[r.zeros(c("shape",n,e,t),c("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(c("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function qn(n,e,t){const r=c("boxes",n,e,t),s=c("scores",n,e,t),a=c("maxOutputSize",n,e,t),o=c("iouThreshold",n,e,t),i=c("scoreThreshold",n,e,t),u=c("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const Bw=async(n,e,t,r,s=ee)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:p}=qn(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(a,o,i,u,l,p);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=qn(n,e,t),p=c("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(a,o,i,u,l,p);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=qn(n,e,t);return[await s.image.nonMaxSuppressionAsync(a,o,i,u,l)]}case"Where":{const a=s.cast(c("condition",n,e,t),"bool"),o=[await s.whereAsync(a)];return a.dispose(),o}case"ListDiff":return s.setdiff1dAsync(c("x",n,e,t),c("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Lw=(n,e,t,r=ee)=>{switch(n.op){case"LowerBound":{const s=c("sortedSequence",n,e,t),a=c("values",n,e,t);return[r.lowerBound(s,a)]}case"TopKV2":{const s=c("x",n,e,t),a=c("k",n,e,t),o=c("sorted",n,e,t),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{const s=c("sortedSequence",n,e,t),a=c("values",n,e,t);return[r.upperBound(s,a)]}case"Unique":{const s=c("x",n,e,t),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=c("x",n,e,t),a=c("axis",n,e,t),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const zw=(n,e,t,r=ee)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=c("default",n,e,t);return[Z(n.name,e,t)||s];case"Placeholder":return[Z(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=c("x",n,e,t);return[Oe(p)]}case"IdentityN":return c("x",n,e,t).map(p=>Oe(p));case"Snapshot":const a=c("x",n,e,t);return[Oe(a)];case"Shape":return[r.tensor1d(c("x",n,e,t).shape,"int32")];case"ShapeN":return c("x",n,e,t).map(p=>r.tensor1d(p.shape));case"Size":return[r.scalar(c("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(c("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=c("x",n,e,t),i=c("data",n,e,t),u=c("message",n,e,t),l=c("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<i.length;p++)console.log(Array.prototype.slice.call(i[p].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class Vw{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=B(0),this.tensorMap=new Map,Ne(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return B(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),z(()=>{const s=Xe(t),a=r.length,o=s.length;g(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=r[i],l=s[i];Ne(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return z(()=>{const s=[];for(let a=0;a<r.length;a++){const o=r[a],i=this.findWithDefault(o,t);s.push(i)}return xe(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const jw=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const a=c("keyDType",n,e,t),o=c("valueDType",n,e,t),i=new Vw(a,o);return r.addHashTable(n.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=c("tableHandle",n,e,t,r),a=c("keys",n,e,t),o=c("values",n,e,t);return[await r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=c("tableHandle",n,e,t,r),a=c("keys",n,e,t),o=c("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=c("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const qw=(n,e,t,r=ee)=>{switch(n.op){case"ResizeBilinear":{const s=c("images",n,e,t),a=c("size",n,e,t),o=c("alignCorners",n,e,t),i=c("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=c("images",n,e,t),a=c("size",n,e,t),o=c("alignCorners",n,e,t),i=c("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=c("image",n,e,t),a=c("boxes",n,e,t),o=c("boxInd",n,e,t),i=c("cropSize",n,e,t),u=c("method",n,e,t),l=c("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,a,o,i,u,l)]}case"ImageProjectiveTransformV3":{const s=c("images",n,e,t),a=c("transforms",n,e,t),o=c("outputShape",n,e,t),i=c("fillValue",n,e,t),u=c("interpolation",n,e,t),l=c("fillMode",n,e,t);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Uw=(n,e,t,r=ee)=>{switch(n.op){case"Equal":return[r.equal(c("a",n,e,t),c("b",n,e,t))];case"NotEqual":return[r.notEqual(c("a",n,e,t),c("b",n,e,t))];case"Greater":return[r.greater(c("a",n,e,t),c("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(c("a",n,e,t),c("b",n,e,t))];case"Less":return[r.less(c("a",n,e,t),c("b",n,e,t))];case"LessEqual":return[r.lessEqual(c("a",n,e,t),c("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(c("a",n,e,t),c("b",n,e,t))];case"LogicalNot":return[r.logicalNot(c("a",n,e,t))];case"LogicalOr":return[r.logicalOr(c("a",n,e,t),c("b",n,e,t))];case"Select":case"SelectV2":return[r.where(c("condition",n,e,t),c("a",n,e,t),c("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(c("a",n,e,t),c("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Ww=(n,e,t,r=ee)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(c("a",n,e,t),c("b",n,e,t),c("transposeA",n,e,t),c("transposeB",n,e,t))];case"Einsum":return[r.einsum(c("equation",n,e,t),...c("tensors",n,e,t))];case"Transpose":return[r.transpose(c("x",n,e,t),c("perm",n,e,t))];case"_FusedMatMul":const[s,a]=c("fusedOps",n,e,t),o=s==="biasadd",i=a==="prelu",u=c("numArgs",n,e,t),l=c("leakyreluAlpha",n,e,t);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,h]=c("args",n,e,t);return[r.fused.matMul({a:c("a",n,e,t),b:c("b",n,e,t),transposeA:c("transposeA",n,e,t),transposeB:c("transposeB",n,e,t),bias:p,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(c("a",n,e,t),c("numLower",n,e,t),c("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Kw=(n,e,t,r=ee)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(c("x",n,e,t),c("axis",n,e,t),c("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(c("x",n,e,t),c("mean",n,e,t),c("variance",n,e,t),c("offset",n,e,t),c("scale",n,e,t),c("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(c("x",n,e,t),c("mean",n,e,t),c("variance",n,e,t),c("offset",n,e,t),c("scale",n,e,t),c("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(c("x",n,e,t),c("radius",n,e,t),c("bias",n,e,t),c("alpha",n,e,t),c("beta",n,e,t))];case"Softmax":return[r.softmax(c("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(c("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Gw=(n,e,t,r=ee)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(c("paramsNestedSplits",n,e,t),c("paramsDenseValues",n,e,t),c("indices",n,e,t),c("outputRaggedRank",n,e,t));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(c("starts",n,e,t),c("limits",n,e,t),c("splits",n,e,t));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(c("shape",n,e,t),c("values",n,e,t),c("defaultValue",n,e,t),c("rowPartitionTensors",n,e,t),c("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Hw=(n,e,t,r=ee)=>{switch(n.op){case"Max":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.max(c("x",n,e,t),i,u)]}case"Mean":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.mean(c("x",n,e,t),i,u)]}case"Min":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.min(c("x",n,e,t),i,u)]}case"Sum":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.sum(c("x",n,e,t),i,u)]}case"All":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.all(c("x",n,e,t),i,u)]}case"Any":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.any(c("x",n,e,t),i,u)]}case"ArgMax":{const i=c("axis",n,e,t);return[r.argMax(c("x",n,e,t),i)]}case"ArgMin":{const i=c("axis",n,e,t);return[r.argMin(c("x",n,e,t),i)]}case"Prod":{const i=c("axis",n,e,t),u=c("keepDims",n,e,t);return[r.prod(c("x",n,e,t),i,u)]}case"Cumprod":{const i=c("axis",n,e,t),u=c("exclusive",n,e,t),l=c("reverse",n,e,t);return[r.cumprod(c("x",n,e,t),i,u,l)]}case"Cumsum":{const i=c("axis",n,e,t),u=c("exclusive",n,e,t),l=c("reverse",n,e,t);return[r.cumsum(c("x",n,e,t),i,u,l)]}case"Bincount":const s=c("x",n,e,t),a=c("weights",n,e,t),o=c("size",n,e,t);return[r.bincount(s,a,o)];case"DenseBincount":{const i=c("x",n,e,t),u=c("weights",n,e,t),l=c("size",n,e,t),p=c("binaryOutput",n,e,t);return[r.denseBincount(i,u,l,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Mw=(n,e,t,r=ee)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=c("n",n,e,t),a=c("axis",n,e,t);let o=c("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{const s=c("x",n,e,t),a=c("indices",n,e,t);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=c("axis",n,e,t),a=c("batchDims",n,e,t),o=c("x",n,e,t),i=c("indices",n,e,t);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=c("dims",n,e,t),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);const o=c("x",n,e,t);return[r.reverse(o,a)]}case"ReverseV2":{const s=c("axis",n,e,t),a=c("x",n,e,t);return[r.reverse(a,s)]}case"Slice":{const s=c("begin",n,e,t),a=c("size",n,e,t);return[r.slice(c("x",n,e,t),s,a)]}case"StridedSlice":{const s=c("begin",n,e,t),a=c("end",n,e,t),o=c("strides",n,e,t),i=c("beginMask",n,e,t),u=c("endMask",n,e,t),l=c("ellipsisMask",n,e,t),p=c("newAxisMask",n,e,t),h=c("shrinkAxisMask",n,e,t),m=c("x",n,e,t);return[r.stridedSlice(m,s,a,o,i,u,l,p,h)]}case"Pack":return z(()=>{const s=c("axis",n,e,t),a=c("tensors",n,e,t),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(l=>{const p=Pe(l.shape,o);if(!p&&!Pe(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return p?l:r.reshape(l,o)});return[r.stack(u,s)]});case"Unpack":{const s=c("axis",n,e,t),a=c("tensor",n,e,t);return r.unstack(a,s)}case"Tile":{const s=c("reps",n,e,t);return[r.tile(c("x",n,e,t),s)]}case"Split":case"SplitV":{const s=c("axis",n,e,t),a=c("numOrSizeSplits",n,e,t),o=c("x",n,e,t);return r.split(o,a,s)}case"ScatterNd":{const s=c("indices",n,e,t),a=c("values",n,e,t),o=c("shape",n,e,t);return[r.scatterND(s,a,o)]}case"GatherNd":{const s=c("x",n,e,t),a=c("indices",n,e,t);return[r.gatherND(s,a)]}case"SparseToDense":{const s=c("sparseIndices",n,e,t),a=c("outputShape",n,e,t),o=c("sparseValues",n,e,t),i=c("defaultValue",n,e,t);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}case"TensorScatterUpdate":{const s=c("indices",n,e,t),a=c("values",n,e,t),o=c("tensor",n,e,t);return[r.tensorScatterUpdate(o,s,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Xw=(n,e,t,r=ee)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(c("indices",n,e,t),c("values",n,e,t),c("denseShape",n,e,t),c("defaultValue",n,e,t));return[s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(c("inputIndices",n,e,t),c("inputShape",n,e,t),c("newShape",n,e,t));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(c("data",n,e,t),c("indices",n,e,t),c("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(c("data",n,e,t),c("indices",n,e,t),c("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Yw=(n,e,t,r=ee)=>{switch(n.op){case"FFT":return[r.fft(c("x",n,e,t))];case"IFFT":return[r.ifft(c("x",n,e,t))];case"RFFT":return[r.rfft(c("x",n,e,t))];case"IRFFT":return[r.irfft(c("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Jw=(n,e,t,r=ee)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(c("input",n,e,t),c("pattern",n,e,t),c("rewrite",n,e,t),c("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(c("data",n,e,t),c("dataSplits",n,e,t),c("separator",n,e,t),c("nGramWidths",n,e,t),c("leftPad",n,e,t),c("rightPad",n,e,t),c("padWidth",n,e,t),c("preserveShortSequences",n,e,t));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(c("input",n,e,t),c("delimiter",n,e,t),c("skipEmpty",n,e,t));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(c("input",n,e,t),c("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const Qw=(n,e,t,r=ee)=>{switch(n.op){case"Cast":return[r.cast(c("x",n,e,t),c("dtype",n,e,t))];case"ExpandDims":{const s=c("axis",n,e,t);return[r.expandDims(c("x",n,e,t),s)]}case"Squeeze":{const s=c("axis",n,e,t);return[r.squeeze(c("x",n,e,t),s)]}case"Reshape":return[r.reshape(c("x",n,e,t),c("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(c("x",n,e,t),c("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(c("x",n,e,t),c("padding",n,e,t),c("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(c("x",n,e,t),c("padding",n,e,t),c("constantValue",n,e,t))];case"SpaceToBatchND":{const s=c("blockShape",n,e,t),a=c("paddings",n,e,t);return[r.spaceToBatchND(c("x",n,e,t),s,a)]}case"BatchToSpaceND":{const s=c("blockShape",n,e,t),a=c("crops",n,e,t);return[r.batchToSpaceND(c("x",n,e,t),s,a)]}case"DepthToSpace":{const s=c("blockSize",n,e,t),a=c("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(c("x",n,e,t),s,a)]}case"BroadcastTo":return[r.broadcastTo(c("x",n,e,t),c("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(c("s0",n,e,t),c("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Ys(n,e,t,r,s=z){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>_w(o,i,u));case"basic_math":return s(()=>xw(o,i,u));case"control":return Fw(o,i,u);case"convolution":return s(()=>Rw(o,i,u));case"creation":return s(()=>Pw(o,i,u));case"dynamic":return Bw(o,i,u);case"evaluation":return s(()=>Lw(o,i,u));case"image":return s(()=>qw(o,i,u));case"graph":return s(()=>zw(o,i,u));case"logical":return s(()=>Uw(o,i,u));case"matrices":return s(()=>Ww(o,i,u));case"normalization":return s(()=>Kw(o,i,u));case"ragged":return s(()=>Gw(o,i,u));case"reduction":return s(()=>Hw(o,i,u));case"slice_join":return s(()=>Mw(o,i,u));case"sparse":return s(()=>Xw(o,i,u));case"spectral":return s(()=>Yw(o,i,u));case"string":return s(()=>Jw(o,i,u));case"transformation":return s(()=>Qw(o,i,u));case"hash_table":return jw(o,i,u,r);case"custom":const l=Xc(o.op);if(l&&l.customExecutor)return l.customExecutor(new Ew(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return st(a)?a.then(o=>[].concat(o)):[].concat(a)}class Js{constructor(e={},t={},r={},s={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Qs(n,e,t,r){const s=new Set,a=[];let o=null,i=null;const u=new Set,l=new Set(Object.keys(n).map(m=>le(m)[0]));r=r||[];const p=new Set(r.map(m=>le(m.name)[0])),h=[...e];for(;h.length>0;){const m=h.pop();if((et(m)||o0(m)||i0(m))&&o==null&&(o=m,i=o.children.map(f=>f.name).filter(f=>s.has(f))),s.add(m.name),t[m.name]==null&&!l.has(m.name)&&!p.has(m.name)){if(m.inputs.length===0){a.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),h.push(f))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function Zw(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(N=>le(N)[0]).map(N=>n.nodes[N]),a=n.initNodes||[],o=N=>t.has(typeof N=="string"?N:N.name);function i(N){return[...new Map(N.map(S=>[S.name,S])).values()]}const u=i([...s,...n.weights,...a]).filter(o),l=i([...u,...Object.values(n.nodes)]).filter(o),p=new Map(l.map(N=>[N.name,N])),h={};for(const N of l){h[N.name]=h[N.name]||0;for(const S of N.children)o(S)||(h[S.name]=Number.POSITIVE_INFINITY),h[S.name]=(h[S.name]||0)+1}const m=Object.entries(h).filter(([,N])=>N===0).map(([N])=>N),f=[...m];for(;m.length>0;){const N=m.pop(),S=p.get(N);for(const x of S.children.filter(o))--h[x.name]===0&&(f.push(x.name),m.push(x.name))}const b=f.map(N=>p.get(N)),k=e0(b,u);return t0(k,u),k}function e0(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),i=t.get(o);for(const u of i.children)!t.has(u.name)||s.has(u.name)||(s.add(u.name),r.push(u.name))}return n.filter(o=>s.has(o.name))}class Qt extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function t0(n,e){const t=new Map(n.map((i,u)=>[i.name,u])),r=new Set(e.map(i=>i.name)),s=i=>r.has(typeof i=="string"?i:i.name),a=new Set(n.map(i=>i.name)),o=i=>a.has(typeof i=="string"?i:i.name);for(const i of n){for(const u of i.children.filter(o)){if(!t.has(u.name))throw new Qt(`Child ${u.name} of node ${i.name} is unreachable.`);if(t.get(i.name)>t.get(u.name))throw new Qt(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!s(i))for(const u of i.inputs){if(!t.has(u.name))throw new Qt(`Input ${u.name} of node ${i.name} is unreachable.`);if(t.get(u.name)>t.get(i.name))throw new Qt(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function n0(n){const e=new Map(n.map((i,u)=>[i.name,u])),t=Number.MAX_SAFE_INTEGER,r=n.map((i,u)=>et(i)?t:u),s=i=>{const u=r[e.get(i.name)];return u??-1},a=n.map((i,u)=>i.children.map(s).reduce((l,p)=>Math.max(l,p),r[u])),o=new Map;for(let i=0;i<n.length;++i){const u=a[i];if(u===t)continue;const l=n[i],p=n[u];o.has(p.name)||o.set(p.name,[]),o.get(p.name).push(l)}return o}const r0=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),s0=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),a0=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function et(n){return r0.has(n.op)}function o0(n){return s0.has(n.op)}function i0(n){return a0.has(n.op)}class Tn{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new Tn(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(a=>a.name).sort(),s=t.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=Qs(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:o}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const l=t.map(h=>h.name),p=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${p}]. Missing the following inputs: [${s}]`)}const i=Zw(this.graph,r),u=n0(i);return{orderedNodes:i,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Ne(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(m=>this.graph.nodes[le(m)[0]]),a=t.map(m=>le(m)[0]),o=new Set(a);let i=a.map(m=>this.graph.nodes[m]);i.length===0&&(i=this._outputs);const u=this.getCompilationKey(s,i);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,i),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=R().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const p={},h={};return z(()=>{const m=new Js(this.weightMap,p,h,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(S=>{const[x,I]=le(S,m),v=[];v[I]=e[S],f[x]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(v))});const b=this.getFrozenTensorIds(f),{orderedNodes:k,nodeLiveUntilMap:N}=l;for(const S of k){if(f[S.name])continue;const x=Ys(S,f,m,this._resourceManager);if(st(x))throw new Error(`The execution of the op '${S.op}' returned a promise. Please use model.executeAsync() instead.`);f[S.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[S.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(S,f,m,b,o,N.get(S.name))}return this.parent==null&&m.dispose(b),t.map(S=>Z(S,f,m))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,a,o,i){if(!(et(t)||o.has(e))){for(const u of r[e])u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length);for(const u of t.inputs){if(et(u))continue;const l=Ks(u.name,r,s);if(l!=null)for(const p of l){if(!p||p.kept||a.has(p.id))continue;const h=i[p.id];h===1?(p.dispose(),delete i[p.id]):h!=null&&i[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,a,o){function i(u){return et(u)||a.has(u.name)}if(!(et(e)||o==null))for(const u of o){if(i(u))continue;const l=Ks(u.name,t,r);for(const p of l)!p||p.kept||s.has(p.id)||p.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=R().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const o=new Js(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,o,t,r),u=t.map(m=>Z(m,i,o)),l=u.map(m=>m.id),p=Object.keys(e).map(m=>e[m].id),h=new Set([...l,...p,...this.weightIds]);return Object.values(i).forEach(m=>{m.forEach(f=>{f&&!f.isDisposed&&!h.has(f.id)&&f.dispose()})}),this.parent==null&&o.dispose(h),u}async executeFunctionAsync(e,t,r){const s=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const a=Object.keys(e),o=a.map(v=>this.graph.nodes[le(v)[0]]),i=r.map(v=>le(v)[0]),u=new Set(i);let l=i.map(v=>this.graph.nodes[v]);l.length===0&&(l=this._outputs);const{usedNodes:p,missingInputs:h,dynamicNode:m,syncInputs:f}=Qs(e,l,this.weightMap,this._initNodes),b=[...o,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:t.currentContext})),k=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[E,_]=le(v),D=[];D[_]=e[v],k[E]=D});const N={},S=this.getFrozenTensorIds(k),x={};for(;b.length>0;){const v=this.processStack(o,b,t,k,x,S,u,N,p);await Promise.all(v)}m==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=l.filter(v=>!et(v)&&!Z(v.name,k,t)).map(v=>v.name);if(I.length>0){let v="";throw m!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${a}]. Consider providing the following inputs: [${h}]. ${v}`)}return k}processStack(e,t,r,s,a,o,i,u,l){const p=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let m="";if(h.node.op==="Enter"&&c("isConstant",h.node,s,r)&&([m]=De(h.node.name,r)),s[h.node.name]==null){const f=Ys(h.node,s,r,this._resourceManager);m||([m]=De(h.node.name,r));const b=r.currentContext;st(f)?p.push(f.then(k=>(s[m]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(k)),r.currentContext=b,this.checkTensorForDisposal(m,h.node,s,r,o,i,u),this.processChildNodes(h.node,t,r,s,a,l),k))):(s[m]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(f)),this.checkTensorForDisposal(m,h.node,s,r,o,i,u),this.processChildNodes(h.node,t,r,s,a,l))}else this.processChildNodes(h.node,t,r,s,a,l)}return p}processChildNodes(e,t,r,s,a,o){e.children.forEach(i=>{const[u]=De(i.name,r);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Z(l,s,r))&&(a[u]=!0,t.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Z(l,s,r))&&(a[u]=!0,t.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=le(t),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);g(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&g(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const a in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[a];o!=null?s[o.name]=e[a]:s[a]=e[a]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=le(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return a!=null?a.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=le(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class u0{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const l0="?tfjs-format=file",c0="model.json";class p0{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=Ss){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new u0}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return st(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await hu(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(s=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new Tn(Gs.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=Gs.Instance.transformGraph(e.modelInitializer);this.initializer=new Tn(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Q?[e]:e,r={};return t.forEach((s,a)=>r[this.structuredOutputKeys[a]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof Q)&&!Array.isArray(e)){const a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(const o in a){const i=a[o];i.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((a,o)=>{var i,u,l;const p=(l=(u=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||u===void 0?void 0:u[o])===null||l===void 0?void 0:l.resourceId;return p!=null?a[o]=this.resourceIdToCapturedInput[p]:a[o]=e[s++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const a=r[s],o=t[a];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&se(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Zs(n,e={},t=Ss){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=h0(n));const r=new p0(n,e,t);return await r.load(),r}function h0(n){return n.endsWith("/")||(n=n+"/"),`${n}${c0}${l0}`}function vn(n,e,t,r){return new(t||(t=Promise))(function(s,a){function o(l){try{u(r.next(l))}catch(p){a(p)}}function i(l){try{u(r.throw(l))}catch(p){a(p)}}function u(l){var p;l.done?s(l.value):(p=l.value,p instanceof t?p:new t(function(h){h(p)})).then(o,i)}u((r=r.apply(n,[])).next())})}function $n(n,e){var t,r,s,a,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(l){return(function(p){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&p[0]?r.return:p[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,p[1])).done)return s;switch(r=0,s&&(p=[2&p[0],s.value]),p[0]){case 0:case 1:s=p;break;case 4:return o.label++,{value:p[1],done:!1};case 5:o.label++,r=p[1],p=[0];continue;case 7:p=o.ops.pop(),o.trys.pop();continue;default:if(!(s=(s=o.trys).length>0&&s[s.length-1])&&(p[0]===6||p[0]===2)){o=0;continue}if(p[0]===3&&(!s||p[1]>s[0]&&p[1]<s[3])){o.label=p[1];break}if(p[0]===6&&o.label<s[1]){o.label=s[1],s=p;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(p);break}s[2]&&o.ops.pop(),o.trys.pop();continue}p=e.call(n,o)}catch(h){p=[6,h],r=0}finally{t=s=0}if(5&p[0])throw p[1];return{value:p[0]?p[1]:void 0,done:!0}})([u,l])}}}var m0={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},ze=224,d0={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},dt={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function b0(n){return n===void 0&&(n={version:1,alpha:1}),vn(this,void 0,void 0,function(){var e,t,r,s,a,o,i;return $n(this,function(u){switch(u.label){case 0:if(Lb==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=n.version.toFixed(2),t=n.alpha?n.alpha.toFixed(2):"",r=-1,s=1,n.modelUrl==null){if(!(e in dt))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(dt));if(!(t in dt[e]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(dt[e])+".");o=dt[e][t].inputRange,r=o[0],s=o[1]}return n.inputRange!=null&&(i=n.inputRange,r=i[0],s=i[1]),[4,(a=new f0(e,t,n.modelUrl,r,s)).load()];case 1:return u.sent(),[2,a]}})})}var f0=(function(){function n(e,t,r,s,a){s===void 0&&(s=-1),a===void 0&&(a=1),this.version=e,this.alpha=t,this.modelUrl=r,this.inputMin=s,this.inputMax=a,this.normalizationConstant=(a-s)/255}return n.prototype.load=function(){return vn(this,void 0,void 0,function(){var e,t,r,s,a=this;return $n(this,function(o){switch(o.label){case 0:return this.modelUrl?(e=this,[4,Zs(this.modelUrl)]):[3,2];case 1:return e.model=o.sent(),[3,4];case 2:return t=dt[this.version][this.alpha].url,r=this,[4,Zs(t,{fromTFHub:!0})];case 3:r.model=o.sent(),o.label=4;case 4:return[4,(s=z(function(){return a.model.predict(We([1,ze,ze,3]))})).data()];case 5:return o.sent(),s.dispose(),[2]}})})},n.prototype.infer=function(e,t){var r=this;return t===void 0&&(t=!1),z(function(){e instanceof Q||(e=Bb(e));var s=A($(G(e,"float32"),r.normalizationConstant),r.inputMin),a=s;(e.shape[0]!==ze||e.shape[1]!==ze)&&(a=bs.resizeBilinear(s,[ze,ze],!0));var o,i=T(a,[-1,ze,ze,3]);if(t){var u=d0[r.version],l=r.model.execute(i,u);o=Yt(l,[1,2])}else{var p=r.model.predict(i);o=j(p,[0,1],[-1,1e3])}return o})},n.prototype.classify=function(e,t){return t===void 0&&(t=3),vn(this,void 0,void 0,function(){var r,s;return $n(this,function(a){switch(a.label){case 0:return[4,g0(r=this.infer(e),t)];case 1:return s=a.sent(),r.dispose(),[2,s]}})})},n})();function g0(n,e){return vn(this,void 0,void 0,function(){var t,r,s,a,o,i,u;return $n(this,function(l){switch(l.label){case 0:return[4,(t=os(n)).data()];case 1:for(r=l.sent(),t.dispose(),s=[],u=0;u<r.length;u++)s.push({value:r[u],index:u});for(s.sort(function(p,h){return h.value-p.value}),a=new Float32Array(e),o=new Int32Array(e),u=0;u<e;u++)a[u]=s[u].value,o[u]=s[u].index;for(i=[],u=0;u<o.length;u++)i.push({className:m0[o[u]],probability:a[u]});return[2,i]}})})}export{y0 as g,b0 as l};
//# sourceMappingURL=tensorflow-bEhwO3aQ.js.map
